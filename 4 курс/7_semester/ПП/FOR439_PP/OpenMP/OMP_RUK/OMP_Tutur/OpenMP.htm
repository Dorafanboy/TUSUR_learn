<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0044)https://computing.llnl.gov/tutorials/openMP/ -->
<HTML><HEAD><TITLE>OpenMP</TITLE>
<SCRIPT language=JavaScript src="OpenMP.files/tutorials.js"></SCRIPT>
<LINK href="OpenMP.files/tutorials.css" type=text/css rel=StyleSheet><!-- BEGIN META TAGS -->
<META content="" name=LLNLRandR>
<META content=global name=distribution>
<META content="Livermore Computing Training" name=description>
<META content=general name=rating>
<META http-equiv=keywords 
content="Lawrence Livermore&#13;&#10;National Laboratory, LLNL, High Performance Computing, parallel, programming, &#13;&#10;HPC, training, openmp, workshops, tutorials, Blaise Barney">
<META 
content="This document is copyrighted U.S.&#13;&#10;Department of Energy under Contract W-7405-Eng-48" 
name=copyright>
<META content="Blaise Barney" name=Author>
<META content=blaiseb@llnl.gov name=email>
<META 
content="DOE:DOE Web sites via&#13;&#10;organizational structure:Laboratories and Other Field Facilities" 
name=Classification>
<META http-equiv=Content-Type content="text/html; charset=utf-8"><!-- END META TAGS -->
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY><BASEFONT><!-- default font size -->
<FORM><!-- required for interactive buttons --><A name=top></A>
<TABLE cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#3f5098>
      <TABLE cellSpacing=0 cellPadding=0 width=900>
        <TBODY>
        <TR>
          <TD background=OpenMP.files/bg1.gif><A name=top></A>
            <SCRIPT language=JavaScript>addNavigation()</SCRIPT>

            <P><BR>
            <H1>OpenMP</H1>
            <P></P></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><A name=TOC></A>
<H2>Table of Contents</H2>
<OL>
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#Abstract">Abstract</A> 
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#Introduction">Introduction</A> 

  <OL>
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Introduction">What 
    is OpenMP?</A> 
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#History">History</A> 
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Goals">Goals of 
    OpenMP</A> </LI></OL>
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#ProgrammingModel">OpenMP 
  Programming Model</A> 
  <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Directives">OpenMP 
  Directives</A> 
  <OL>
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#Directives">Fortran 
    Directive Format</A> 
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#CFormat">C/C++ 
    Directive Format</A> 
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Scoping">Directive 
    Scoping</A> 
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#ParallelRegion">PARALLEL 
    Construct</A> 
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#WorkSharing">Work-Sharing 
    Constructs</A> 
    <OL>
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#DO">DO / for 
      Directive</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#SECTIONS">SECTIONS 
      Directive</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#WORKSHARE">WORKSHARE 
      Directive</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#SINGLE">SINGLE 
      Directive</A> </LI></OL>
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Combined">Combined 
    Parallel Work-Sharing Constructs</A> 
    <OL>
      <LI>PARALLEL DO / parallel for Directive 
      <LI>PARALLEL SECTIONS Directive 
      <LI>PARALLEL WORKSHARE Directive </LI></OL>
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#Synchronization">Synchronization 
    Constructs</A> 
    <OL>
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#MASTER">MASTER 
      Directive</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#CRITICAL">CRITICAL 
      Directive</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#BARRIER">BARRIER 
      Directive</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#ATOMIC">ATOMIC 
      Directive</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#FLUSH">FLUSH 
      Directive</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#ORDERED">ORDERED 
      Directive</A> </LI></OL>
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#THREADPRIVATE">THREADPRIVATE 
    Directive</A> 
    <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Clauses">Data 
    Scope Attribute Clauses</A> 
    <OL>
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#PRIVATE">PRIVATE 
      Clause</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#SHARED">SHARED 
      Clause</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#DEFAULT">DEFAULT 
      Clause</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#FIRSTPRIVATE">FIRSTPRIVATE 
      Clause</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#LASTPRIVATE">LASTPRIVATE 
      Clause</A> 
      <LI><A href="https://computing.llnl.gov/tutorials/openMP/#COPYIN">COPYIN 
      Clause</A> 
      <LI><A 
      href="https://computing.llnl.gov/tutorials/openMP/#REDUCTION">REDUCTION 
      Clause</A> </LI></OL>
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#ClausesDirectives">Clauses 
    / Directives Summary</A> 
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#BindingNesting">Directive 
    Binding and Nesting Rules</A> </LI></OL>
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#RunTimeLibrary">Run-Time 
  Library Routines</A> 
  <OL>
    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_SET_NUM_THREADS">OMP_SET_NUM_THREADS</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_NUM_THREADS">OMP_GET_NUM_THREADS</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_MAX_THREADS">OMP_GET_MAX_THREADS</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_THREAD_NUM">OMP_GET_THREAD_NUM</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_NUM_PROCS">OMP_GET_NUM_PROCS</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_IN_PARALLEL">OMP_IN_PARALLEL</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_SET_DYNAMIC">OMP_SET_DYNAMIC</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_DYNAMIC">OMP_GET_DYNAMIC</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_SET_NESTED">OMP_SET_NESTED</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_NESTED">OMP_GET_NESTED</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_INIT_LOCK">OMP_INIT_LOCK</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_DESTROY_LOCK">OMP_DESTROY_LOCK</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_SET_LOCK">OMP_SET_LOCK</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_UNSET_LOCK">OMP_UNSET_LOCK</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_TEST_LOCK">OMP_TEST_LOCK</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_WTIME">OMP_GET_WTIME</A> 

    <LI><A 
    href="https://computing.llnl.gov/tutorials/openMP/#OMP_GET_WTICK">OMP_GET_WTICK</A> 
    </LI></OL>
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#EnvironmentVariables">Environment 
  Variables</A> 
  <LI><A href="https://computing.llnl.gov/tutorials/openMP/#Issues">Memory and 
  Performance Issues</A> 
  <LI><A href="https://computing.llnl.gov/tutorials/openMP/#LLNL">LLNL Specific 
  Information and Recommendations</A> 
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/#References">References and 
  More Information</A> 
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/exercise.html">Exercise</A> <!----------
<LI><A HREF="javascript://" onClick="resetTop('../index.html');">Workshop Home</A>
-----------></LI></OL><!----------------------------------------------------------------------------><A 
name=Abstract><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>Abstract</SPAN> 
</TD></TR></TBODY></TABLE>
<P><BR>OpenMP is an Application Program Interface (API), jointly defined by a 
group of major computer hardware and software vendors. OpenMP provides a 
portable, scalable model for developers of shared memory parallel applications. 
The API supports C/C++ and Fortran on multiple architectures, including UNIX 
&amp; Windows NT. This tutorial covers most of the major features of OpenMP, 
including its various constructs and directives for specifying parallel regions, 
work sharing, synchronization and data environment. Runtime library functions 
and environment variables are also covered. This tutorial includes both C and 
Fortran example codes and a lab exercise. 
<P>Level/Prerequisites: Geared to those who are new to parallel programming with 
OpenMP. Basic understanding of parallel programming in C or Fortran assumed. For 
those who are unfamiliar with Parallel Programming in general, the material 
covered in <A href="https://computing.llnl.gov/tutorials/parallel_comp" 
target=ec3500>EC3500: Introduction to Parallel Computing</A> would be helpful. 
<BR><BR><!--------------------------------------------------------------------------><A 
name=Introduction><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>Introduction</SPAN> 
</TD></TR></TBODY></TABLE>
<H2>What is OpenMP?</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>OpenMP Is: </SPAN>
<UL>
  <P>
  <LI>An Application Program Interface (API) that may be used to explicitly 
  direct <SPAN class=emphasis>multi-threaded, shared memory parallelism</SPAN> 
  <P></P>
  <LI>Comprised of three primary API components: 
  <UL>
    <LI>Compiler Directives 
    <LI>Runtime Library Routines 
    <LI>Environment Variables </LI></UL>
  <P></P>
  <LI>Portable: 
  <UL>
    <LI>The API is specified for C/C++ and Fortran 
    <LI>Multiple platforms have been implemented including most Unix platforms 
    and Windows NT </LI></UL>
  <P></P>
  <LI>Standardized: 
  <UL>
    <LI>Jointly defined and endorsed by a group of major computer hardware and 
    software vendors 
    <LI>Expected to become an ANSI standard later??? </LI></UL>
  <P></P>
  <LI>What does OpenMP stand for? 
  <UL><FONT color=blue>Open</FONT> specifications for <FONT color=blue>Multi 
    Processing</FONT> via collaborative work between interested parties from the 
    hardware and software industry, government and academia. </UL></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>OpenMP Is Not: </SPAN>
<UL>
  <P>
  <LI>Meant for distributed memory parallel systems (by itself) 
  <P></P>
  <LI>Necessarily implemented identically by all vendors 
  <P></P>
  <LI>Guaranteed to make the most efficient use of shared memory (currently 
  there are no data locality constructs) </LI></UL>
<P>
<HR>

<P><A name=History></A>
<H2>History</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> 
<SPAN class=heading3>Ancient History</SPAN> 
<UL>
  <P>
  <LI>In the early 90's, vendors of shared-memory machines supplied similar, 
  directive-based, Fortran programming extensions: 
  <UL>
    <LI>The user would augment a serial Fortran program with directives 
    specifying which loops were to be parallelized 
    <LI>The compiler would be responsible for automatically parallelizing such 
    loops across the SMP processors </LI></UL>
  <P></P>
  <LI>Implementations were all functionally similar, but were diverging (as 
  usual) 
  <P></P>
  <LI>First attempt at a standard was the draft for ANSI X3H5 in 1994. It was 
  never adopted, largely due to waning interest as distributed memory machines 
  became popular. </LI></UL><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>More Recent History</SPAN> 
<UL>
  <P>
  <LI>The OpenMP standard specification started in the spring of 1997, taking 
  over where ANSI X3H5 had left off, as newer shared memory machine 
  architectures started to become prevalent. 
  <P></P>
  <LI>Partners in the OpenMP standard specification included: 
  <BR><I>(Disclaimer: all partner names derived from the <A 
  href="http://www.openmp.org/" target=openmporg1>OpenMP web site</A>)</I> 
  <P>OpenMP Architecture Review Board (open to new members) 
  <UL>
    <LI>Compaq / Digital 
    <LI>Hewlett-Packard Company 
    <LI>Intel Corporation 
    <LI>International Business Machines (IBM) 
    <LI>Kuck &amp; Associates, Inc. (KAI) 
    <LI>Silicon Graphics, Inc. 
    <LI>Sun Microsystems, Inc. 
    <LI>U.S. Department of Energy ASC program </LI></UL>
  <P>Endorsing software vendors: 
  <UL>
    <LI>Absoft Corporation 
    <LI>Edinburgh Portable Compilers 
    <LI>GENIAS Software GmBH 
    <LI>Myrias Computer Technologies, Inc. 
    <LI>The Portland Group, Inc. (PGI) </LI></UL>
  <P>Endorsing application developers: 
  <UL>
    <LI>ADINA R&amp;D, Inc. 
    <LI>ANSYS, Inc. 
    <LI>Dash Associates 
    <LI>Fluent, Inc. 
    <LI>ILOG CPLEX Division 
    <LI>Livermore Software Technology Corporation (LSTC) 
    <LI>MECALOG SARL 
    <LI>Oxford Molecular Group PLC 
    <LI>The Numerical Algorithms Group Ltd.(NAG) </LI></UL></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Documentation Release History</SPAN> 
<UL>
  <P>
  <LI>Oct 1997: Fortran version 1.0 
  <P></P>
  <LI>Oct 1998: C/C++ version 1.0 
  <P></P>
  <LI>Nov 2000: Fortran version 2.0 
  <P></P>
  <LI>Mar 2002: C/C++ version 2.0 
  <P></P>
  <LI>May 2005: C/C++ and Fortran version 2.5 
  <P></P>
  <LI>???: version 3.0 </LI></UL>
<P><IMG height=36 src="OpenMP.files/openmp_logo.gif" width=100 border=0> 
<UL>
  <LI>Visit the OpenMP website at <A href="http://www.openmp.org/" 
  target=openmporg2>http://www.openmp.org/</A> for more information, including 
  API specifications, FAQ, presentations, discussions, media releases, calendar 
  and membership application. </LI></UL>
<P>
<HR>

<P><A name=Goals></A>
<H2>Goals of OpenMP</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Standardization:</SPAN> 
<UL>
  <LI>Provide a standard among a variety of shared memory 
  architectures/platforms </LI></UL><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN class=heading3>Lean and 
Mean:</SPAN> 
<UL>
  <LI>Establish a simple and limited set of directives for programming shared 
  memory machines. Significant parallelism can be implemented by using just 3 or 
  4 directives. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Ease of Use:</SPAN> 
<UL>
  <LI>Provide capability to incrementally parallelize a serial program, unlike 
  message-passing libraries which typically require an all or nothing approach 
  <P></P>
  <LI>Provide the capability to implement both coarse-grain and fine-grain 
  parallelism </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Portability:</SPAN> 
<UL>
  <P>
  <LI>Supports Fortran (77, 90, and 95), C, and C++
  <P></P>
  <LI>Public forum for API and membership </LI></UL><!--------------------------------------------------------------------------><A 
name=ProgrammingModel><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Programming Model</SPAN> 
    </TD></TR></TBODY></TABLE>
<P><BR><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Shared Memory, Thread Based Parallelism:</SPAN> 
<UL>
  <LI>OpenMP is based upon the existence of multiple threads in the shared 
  memory programming paradigm. A shared memory process consists of multiple 
  threads. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Explicit Parallelism:</SPAN> 
<UL>
  <LI>OpenMP is an explicit (not automatic) programming model, offering the 
  programmer full control over parallelization. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Fork - Join Model:</SPAN> 
<UL>
  <LI>OpenMP uses the fork-join model of parallel execution: 
  <P><IMG height=172 alt="Fork - Join Model" src="OpenMP.files/fork_join1.gif" 
  width=510 border=0>
  <P>
  <P></P>
  <LI>All OpenMP programs begin as a single process: the <FONT 
  color=red><B>master thread</B></FONT>. The master thread executes sequentially 
  until the first <FONT color=blue><B>parallel region</B></FONT> construct is 
  encountered.
  <P></P>
  <LI><B>FORK:</B> the master thread then creates a <B><I>team</B></I> of 
  parallel threads 
  <P></P>
  <LI>The statements in the program that are enclosed by the parallel region 
  construct are then executed in parallel among the various team threads 
  <P></P>
  <LI><B>JOIN:</B> When the team threads complete the statements in the parallel 
  region construct, they synchronize and terminate, leaving only the master 
  thread </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Compiler Directive Based:</SPAN> 
<UL>
  <LI>Most OpenMP parallelism is specified through the use of compiler 
  directives which are imbedded in C/C++ or Fortran source code. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Nested Parallelism Support:</SPAN> 
<UL>
  <LI>The API provides for the placement of parallel constructs inside of other 
  parallel constructs. 
  <P></P>
  <LI>Implementations may or may not support this feature. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Dynamic Threads:</SPAN> 
<UL>
  <LI>The API provides for dynamically altering the number of threads which may 
  used to execute different parallel regions. 
  <P></P>
  <LI>Implementations may or may not support this feature. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>I/O:</SPAN> 
<UL>
  <LI>OpenMP specifies nothing about parallel I/O. This is particularly 
  important if multiple threads attempt to write/read from the same file. 
  <P></P>
  <LI>If every thread conducts I/O to a different file, the issues are not as 
  significant. 
  <P></P>
  <LI>It is entirely up to the programmer to insure that I/O is conducted 
  correctly within the context of a multi-threaded program. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>FLUSH Often?:</SPAN> 
<UL>
  <LI>OpenMP provides a "relaxed-consistency" and "temporary" view of thread 
  memory (in their words). In other words, threads can "cache" their data and 
  are not required to maintain exact consistency with real memory all of the 
  time. 
  <P></P>
  <LI>When it is critical that all threads view a shared variable identically, 
  the programmer is responsible for insuring that the variable is FLUSHed by all 
  threads as needed. 
  <P></P>
  <LI>More on this later... </LI></UL><BR>
<P>
<HR>

<P>
<H2>Example OpenMP Code Structure</H2>
<UL>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - General Code 
        Structure</FONT></SPAN> 
        <HR>
<PRE>       PROGRAM HELLO

       INTEGER VAR1, VAR2, VAR3

       <I>Serial code </I>
             .
             .
             .

       <I>Beginning of parallel section. Fork a team of threads. 
       Specify variable scoping </I>

<FONT color=red>!$OMP PARALLEL PRIVATE(VAR1, VAR2) SHARED(VAR3)

       <I>Parallel section executed by all threads </I>
             .
             .
             .

       <I>All threads join master thread and disband </I>

!$OMP END PARALLEL</FONT>

       <I>Resume serial code </I>
             .
             .
             .

       END
</B></PRE></FONT></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - General Code 
        Structure</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;

main ()  {

int var1, var2, var3;

<I>Serial code </I>
      .
      .
      .

<I>Beginning of parallel section. Fork a team of threads.
Specify variable scoping </I>

<FONT color=red>#pragma omp parallel private(var1, var2) shared(var3)
  {

  <I>Parallel section executed by all threads </I>
        .
        .
        .

  <I>All threads join master thread and disband </I>

  }  </FONT>

<I>Resume serial code </I>
      .
      .
      .

}
</B></PRE></TD></TR></TBODY></TABLE></P></UL><!--------------------------------------------------------------------------><A 
name=Directives><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Fortran Directives Format</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> (case insensitive) 
<UL>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH>sentinel</TH>
      <TH>directive-name</TH>
      <TH>[clause ...]</TH></TR>
    <TR vAlign=top>
      <TD>All Fortran OpenMP directives must begin with a sentinel. The 
        accepted sentinels depend upon the type of Fortran source. Possible 
        sentinels are: <PRE><B>    !$OMP
    C$OMP
    *$OMP </B></PRE></TD>
      <TD>A valid OpenMP directive. Must appear after the sentinel and before 
        any clauses. </TD>
      <TD>Optional. Clauses can be in any order, and repeated as necessary 
        unless otherwise restricted. </TD></TR></TBODY></TABLE></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Example:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><PRE><B>
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(BETA,PI)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Fixed Form Source:</SPAN> 
<UL>
  <P>
  <LI><TT><B>!$OMP C$OMP *$OMP</B></TT> are accepted sentinels and must start in 
  column 1 
  <P></P>
  <LI>All Fortran fixed form rules for line length, white space, continuation 
  and comment columns apply for the entire directive line 
  <P></P>
  <LI>Initial directive lines must have a space/zero in column 6. 
  <P></P>
  <LI>Continuation lines must have a non-space/zero in column 6. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Free Form Source:</SPAN> 
<UL>
  <P>
  <LI><TT><B>!$OMP</B></TT> is the only accepted sentinel. Can appear in any 
  column, but must be preceded by white space only. 
  <P></P>
  <LI>All Fortran free form rules for line length, white space, continuation and 
  comment columns apply for the entire directive line 
  <P></P>
  <LI>Initial directive lines must have a space after the sentinel. 
  <P></P>
  <LI>Continuation lines must have an ampersand as the last non-blank character 
  in a line. The following line must begin with a sentinel and then the 
  continuation directives. </LI></UL><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN class=heading3>General 
Rules:</SPAN> 
<UL>
  <P>
  <LI>Comments can not appear on the same line as a directive 
  <P></P>
  <LI>Only one directive-name may be specified per directive 
  <P></P>
  <LI>Fortran compilers which are OpenMP enabled generally include a command 
  line option which instructs the compiler to activate and interpret all OpenMP 
  directives. 
  <P></P>
  <LI>Several Fortran OpenMP directives come in pairs and have the form shown 
  below. The "end" directive is optional but advised for readability. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><PRE><B>
!$OMP  <I>directive </I>

    <I>[ structured block of code ]</I>

!$OMP end  <I>directive</I>

</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=CFormat><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>C / C++ Directives Format</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH>#pragma omp </TH>
      <TH><B>directive-name</B></TH>
      <TH><B>[clause, ...]</B></TH>
      <TH><B>newline</B></TH>
    <TR vAlign=top>
      <TD>Required for all OpenMP C/C++ directives. 
      <TD>A valid OpenMP directive. Must appear after the pragma and before 
        any clauses. 
      <TD>Optional. Clauses can be in any order, and repeated as necessary 
        unless otherwise restricted. 
      <TD>Required. Precedes the structured block which is enclosed by this 
        directive. </TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Example:</SPAN> 
<UL>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><PRE><B>
#pragma omp parallel default(shared) private(beta,pi)

</B></PRE></TD></TR></TBODY></TABLE></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>General Rules:</SPAN> 
<UL>
  <LI>Case sensitive 
  <P></P>
  <LI>Directives follow conventions of the C/C++ standards for compiler 
  directives 
  <P></P>
  <LI>Only one directive-name may be specified per directive 
  <P></P>
  <LI>Each directive applies to at most one succeeding statement, which must be 
  a structured block. 
  <P></P>
  <LI>Long directive lines can be "continued" on succeeding lines by escaping 
  the newline character with a backslash ("\") at the end of a directive line. 
  </LI></UL><!--------------------------------------------------------------------------><A 
name=Scoping><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Directive Scoping</H2>Do we do this now...or do it later? Oh well, let's get 
it over with early... 
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Static (Lexical) Extent:</SPAN> 
<UL>
  <LI>The code textually enclosed between the beginning and the end of a 
  structured block following a directive. 
  <P></P>
  <LI>The static extent of a directives does not span multiple routines or code 
  files </LI></UL><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> 
<SPAN class=heading3>Orphaned Directive:</SPAN> 
<UL>
  <LI>An OpenMP directive that appears independently from another enclosing 
  directive is said to be an orphaned directive. It exists outside of another 
  directive's static (lexical) extent. 
  <P></P>
  <LI>Will span routines and possibly code files </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Dynamic Extent:</SPAN> 
<UL>
  <LI>The dynamic extent of a directive includes both its static (lexical) 
  extent and the extents of its orphaned directives. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Example:</SPAN> 
<UL>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR vAlign=top>
      <TD bgColor=#eeeeee><PRE>      PROGRAM TEST
      ...
<FONT color=red>!$OMP PARALLEL</FONT>
      ...
<FONT color=red>!$OMP DO</FONT>
      DO I=...
      ...
      CALL SUB1
      ...
      ENDDO
      ...
      CALL SUB2
      ...
<FONT color=red>!$OMP END PARALLEL</FONT>
</PRE></TD>
      <TD bgColor=#eeeeee><PRE>      SUBROUTINE SUB1
      ...
<FONT color=red>!$OMP CRITICAL</FONT>
      ...
<FONT color=red>!$OMP END CRITICAL</FONT>
      END


      SUBROUTINE SUB2
      ...
<FONT color=red>!$OMP SECTIONS</FONT>
      ...
<FONT color=red>!$OMP END SECTIONS</FONT>
      ...
      END
</PRE></TD></TR>
    <TR vAlign=top>
      <TD align=middle width="50%" bgColor=#dddddd><SPAN class=heading3>STATIC 
        EXTENT</SPAN> <BR>The <TT>DO</TT> directive occurs within an enclosing 
        parallel region </TD>
      <TD align=middle width="50%" bgColor=#dddddd><SPAN 
        class=heading3>ORPHANED DIRECTIVES</SPAN> <BR>The <TT>CRITICAL</TT> and 
        <TT>SECTIONS</TT> directives occur outside an enclosing parallel region 
      </TD></TR>
    <TR vAlign=top>
      <TD align=middle bgColor=#dddddd colSpan=2><SPAN class=heading3>DYNAMIC 
        EXTENT</SPAN> <BR>The CRITICAL and SECTIONS directives occur within the 
        dynamic extent of the DO and PARALLEL directives. 
</TD></TR></TBODY></TABLE></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Why Is This Important?</SPAN> 
<UL>
  <P>
  <LI>OpenMP specifies a number of scoping rules on how directives may associate 
  (bind) and nest within each other 
  <P></P>
  <LI>Illegal and/or incorrect programs may result if the OpenMP binding and 
  nesting rules are ignored 
  <P></P>
  <LI>See <A 
  href="https://computing.llnl.gov/tutorials/openMP/#BindingNesting">Directive 
  Binding and Nesting Rules</A> for specific details </LI></UL><!--------------------------------------------------------------------------><A 
name=ParallelRegion><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>PARALLEL Region Construct</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>A parallel region is a block of code that will be executed by multiple 
  threads. This is the fundamental OpenMP parallel construct. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP PARALLEL <I>[clause ...] </I>
               IF <I>(scalar_logical_expression) </I>
               PRIVATE <I>(list) </I>
               SHARED <I>(list) </I>
               DEFAULT (PRIVATE | SHARED | NONE) 
               FIRSTPRIVATE <I>(list) </I>
               REDUCTION <I>(operator: list) </I>
               COPYIN <I>(list) </I>
               NUM_THREADS <I>(scalar-integer-expression)</I>

   <I>block</I>

!$OMP END PARALLEL

</PRE></TD></TR>
    <TR>
      <TH>C/C++ </TH>
      <TD><PRE>#pragma omp parallel <I>[clause ...]  newline </I>
                     if <I>(scalar_expression) </I>
                     private <I>(list) </I>
                     shared <I>(list) </I>
                     default (shared | none) 
                     firstprivate <I>(list) </I>
                     reduction <I>(operator: list) </I>
                     copyin <I>(list) </I>
                     num_threads <I>(integer-expression)</I>

 
   <I>structured_block</I>

</PRE></TD></TR></TBODY></TABLE>
  <P></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>When a thread reaches a PARALLEL directive, it creates a team of threads 
  and becomes the master of the team. The master is a member of that team and 
  has thread number 0 within that team. 
  <P></P>
  <LI>Starting from the beginning of this parallel region, the code is 
  duplicated and all threads will execute that code. 
  <P></P>
  <LI>There is an implied barrier at the end of a parallel section. Only the 
  master thread continues execution past this point. 
  <P></P>
  <LI>If any thread terminates within a parallel region, all threads in the team 
  will terminate, and the work done up until that point is undefined. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>How Many Threads?</SPAN> 
<UL>
  <LI>The number of threads in a parallel region is determined by the following 
  factors, in order of precedence: 
  <OL>
    <P>
    <LI>Evaluation of the <TT><B>IF</B></TT> clause 
    <P></P>
    <LI>Setting of the <TT><B>NUM_THREADS</B></TT> clause 
    <P></P>
    <LI>Use of the <TT><B>omp_set_num_threads()</B></TT> library function 
    <P></P>
    <LI>Setting of the <B>OMP_NUM_THREADS</B> environment variable 
    <P></P>
    <LI>Implementation default - usually the number of CPUs on a node, though it 
    could be dynamic (see next bullet). </LI></OL>
  <P></P>
  <LI>Threads are numbered from 0 (master thread) to N-1 </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Dynamic Threads:</SPAN> 
<UL>
  <LI>Use the <TT><B>omp_get_dynamic()</B></TT> library function to determine if 
  dynamic threads are enabled. 
  <P></P>
  <LI>If supported, the two methods available for enabling dynamic threads are: 
  <OL>
    <P>
    <LI>The <TT><B>omp_set_dynamic()</B></TT> library routine 
    <P></P>
    <LI>Setting of the <B>OMP_DYNAMIC</B> environment variable to TRUE 
  </LI></OL></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Nested Parallel Regions:</SPAN> 
<UL>
  <P>
  <LI>Use the <TT><B>omp_get_nested()</B></TT> library function to determine if 
  nested parallel regions are enabled. 
  <P></P>
  <LI>The two methods available for enabling nested parallel regions (if 
  supported) are: 
  <OL>
    <P>
    <LI>The <TT><B>omp_set_nested()</B></TT> library routine 
    <P></P>
    <LI>Setting of the <B>OMP_NESTED</B> environment variable to TRUE </LI></OL>
  <P></P>
  <LI>If not supported, a parallel region nested within another parallel region 
  results in the creation of a new team, consisting of one thread, by default. 
  </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Clauses:</SPAN> 
<UL>
  <P>
  <LI><B>IF</B> clause: If present, it must evaluate to .TRUE. (Fortran) or 
  non-zero (C/C++) in order for a team of threads to be created. Otherwise, the 
  region is executed serially by the master thread. 
  <P></P>
  <LI>The remaining clauses are described in detail later, in the <A 
  href="https://computing.llnl.gov/tutorials/openMP/#Clauses">Data Scope 
  Attribute Clauses</A> section. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>A parallel region must be a structured block that does not span multiple 
  routines or code files 
  <P></P>
  <LI>It is illegal to branch into or out of a parallel region 
  <P></P>
  <LI>Only a single IF clause is permitted 
  <P></P>
  <LI>Only a single NUM_THREADS clause is permitted </LI></UL>
<P>
<HR>

<P>
<H2>Example: Parallel Region</H2>
<UL>
  <LI>Simple "Hello World" program 
  <UL>
    <LI>Every thread executes all code enclosed in the parallel section 
    <LI>OpenMP library routines are used to obtain thread identifiers and total 
    number of threads </LI></UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - Parallel Region 
        Example</SPAN> 
        <HR>
<PRE>       PROGRAM HELLO

       INTEGER NTHREADS, TID, <FONT color=red>OMP_GET_NUM_THREADS</FONT>,
     +   <FONT color=red>OMP_GET_THREAD_NUM</FONT>

C     Fork a team of threads giving them their own copies of variables
<FONT color=red>!$OMP PARALLEL PRIVATE(TID)</FONT>

C     Obtain and print thread id
      TID = <FONT color=red>OMP_GET_THREAD_NUM()</FONT>
      PRINT *, 'Hello World from thread = ', TID

C     Only master thread does this
      IF (TID .EQ. 0) THEN
        NTHREADS = <FONT color=red>OMP_GET_NUM_THREADS()</FONT>
        PRINT *, 'Number of threads = ', NTHREADS
      END IF

C     All threads join master thread and disband
<FONT color=red>!$OMP END PARALLEL</FONT>

       END
</B></PRE></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - Parallel Region 
        Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;

main ()  {

int nthreads, tid;

/* Fork a team of threads giving them their own copies of variables */
<FONT color=red>#pragma omp parallel private(tid)</FONT>
  {

  /* Obtain and print thread id */
  tid = <FONT color=red>omp_get_thread_num()</FONT>;
  printf("Hello World from thread = %d\n", tid);

  /* Only master thread does this */
  if (tid == 0) 
    {
    nthreads = <FONT color=red>omp_get_num_threads()</FONT>;
    printf("Number of threads = %d\n", nthreads);
    }

  }  /* All threads join master thread and terminate */

}
</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=WorkSharing><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Work-Sharing Constructs</H2>
<UL>
  <LI>A work-sharing construct divides the execution of the enclosed code region 
  among the members of the team that encounter it. 
  <P></P>
  <LI>Work-sharing constructs do not launch new threads 
  <P></P>
  <LI>There is no implied barrier upon entry to a work-sharing construct, 
  however there is an implied barrier at the end of a work sharing construct. 
  </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Types of Work-Sharing Constructs:</SPAN> 
<UL>NOTE: The Fortran <B><TT>workshare</TT></B> construct is not covered here. 

  <P>
  <TABLE cellSpacing=0 cellPadding=5 border=0>
    <TBODY>
    <TR vAlign=top>
      <TD><B>DO / for</B> - shares iterations of a loop across the team. 
        Represents a type of "data parallelism". 
      <TD><B>SECTIONS</B> - breaks work into separate, discrete sections. Each 
        section is executed by a thread. Can be used to implement a type of 
        "functional parallelism". 
      <TD><B>SINGLE</B> - serializes a section of code 
    <TR vAlign=top align=middle>
      <TD><IMG height=286 alt="DO / for loop work-sharing construct" 
        src="OpenMP.files/work_share1.gif" width=196 border=0> 
      <TD><IMG height=286 alt="SECTIONS work-sharing construct" 
        src="OpenMP.files/work_share2.gif" width=196 border=0> 
      <TD><IMG height=286 alt="SINGLE work-sharing construct" 
        src="OpenMP.files/work_share3.gif" width=196 border=0> 
  </TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>A work-sharing construct must be enclosed dynamically within a parallel 
  region in order for the directive to execute in parallel. 
  <P></P>
  <LI>Work-sharing constructs must be encountered by all members of a team or 
  none at all 
  <P></P>
  <LI>Successive work-sharing constructs must be encountered in the same order 
  by all members of a team </LI></UL><!--------------------------------------------------------------------------><A 
name=DO><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Work-Sharing Constructs <BR>DO / for Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <LI>The DO / for directive specifies that the iterations of the loop 
  immediately following it must be executed in parallel by the team. This 
  assumes a parallel region has already been initiated, otherwise it executes in 
  serial on a single processor. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP DO <I>[clause ...] </I>
         SCHEDULE <I>(type [,chunk]) </I>
         ORDERED 
         PRIVATE <I>(list) </I>
         FIRSTPRIVATE <I>(list) </I>
         LASTPRIVATE <I>(list) </I>
         SHARED <I>(list) </I>
         REDUCTION <I>(operator | intrinsic : list) </I>

   <I>do_loop</I>

!$OMP END DO  [ NOWAIT ]

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp for <I>[clause ...]  newline </I>
                schedule <I>(type [,chunk]) </I>
                ordered
                private <I>(list) </I>
                firstprivate <I>(list) </I>
                lastprivate <I>(list) </I>
                shared <I>(list) </I>
                reduction <I>(operator: list) </I>
                nowait 

   <I>for_loop</I>

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Clauses:</SPAN> 
<UL>
  <P>
  <LI><B>SCHEDULE</B>: Describes how iterations of the loop are divided among 
  the threads in the team. The default schedule is implementation dependent. 
  <DL>
    <P>
    <DT>STATIC 
    <DD>Loop iterations are divided into pieces of size <I>chunk</I> and then 
    statically assigned to threads. If chunk is not specified, the iterations 
    are evenly (if possible) divided contiguously among the threads. 
    <P></P>
    <DT>DYNAMIC 
    <DD>Loop iterations are divided into pieces of size <I>chunk</I>, and 
    dynamically scheduled among the threads; when a thread finishes one chunk, 
    it is dynamically assigned another. The default chunk size is 1. 
    <P></P>
    <DT>GUIDED 
    <DD>For a chunk size of 1, the size of each chunk is proportional to the 
    number of unassigned iterations divided by the number of threads, decreasing 
    to 1. For a chunk size with value k (greater than 1), the size of each chunk 
    is determined in the same way with the restriction that the chunks do not 
    contain fewer than k iterations (except for the last chunk to be assigned, 
    which may have fewer than k iterations). The default chunk size is 1. 
    <P></P>
    <DT>RUNTIME 
    <DD>The scheduling decision is deferred until runtime by the environment 
    variable OMP_SCHEDULE. It is illegal to specify a chunk size for this 
    clause. </DD></DL>
  <P></P>
  <LI><B>NO WAIT / nowait</B>: If specified, then threads do not synchronize at 
  the end of the parallel loop. 
  <P></P>
  <LI><B>ORDERED</B>: Specifies that the iterations of the loop must be executed 
  as they would be in a serial program. 
  <P></P>
  <LI>Other clauses are described in detail later, in the <A 
  href="https://computing.llnl.gov/tutorials/openMP/#Clauses">Data Scope 
  Attribute Clauses</A> section. </LI></UL>
<UL></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>The DO loop can not be a DO WHILE loop, or a loop without loop control. 
  Also, the loop iteration variable must be an integer and the loop control 
  parameters must be the same for all threads. 
  <P></P>
  <LI>Program correctness must not depend upon which thread executes a 
  particular iteration. 
  <P></P>
  <LI>It is illegal to branch out of a loop associated with a DO/for directive. 
  <P></P>
  <LI>The chunk size must be specified as a loop invarient integer expression, 
  as there is no synchronization during its evaluation by different threads. 
  <P></P>
  <LI>ORDERED and SCHEDULE clauses may appear once each. </LI></UL>
<P>
<HR>

<P>
<H2>Example: DO / for Directive</H2>
<UL>
  <LI>Simple vector-add program 
  <UL>
    <LI>Arrays A, B, C, and variable N will be shared by all threads. 
    <LI>Variable I will be private to each thread; each thread will have its own 
    unique copy. 
    <LI>The iterations of the loop will be distributed dynamically in CHUNK 
    sized pieces. 
    <LI>Threads will not synchronize upon completing their individual pieces of 
    work (NOWAIT). </LI></UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - DO Directive 
        Example</SPAN> 
        <HR>
<PRE>      PROGRAM VEC_ADD_DO

      INTEGER N, CHUNKSIZE, CHUNK, I
      PARAMETER (N=1000) 
      PARAMETER (CHUNKSIZE=100) 
      REAL A(N), B(N), C(N)

!     Some initializations
      DO I = 1, N
        A(I) = I * 1.0
        B(I) = A(I)
      ENDDO
      CHUNK = CHUNKSIZE
        
<FONT color=red>!$OMP PARALLEL SHARED(A,B,C,CHUNK) PRIVATE(I)</FONT>

<FONT color=red>!$OMP DO SCHEDULE(DYNAMIC,CHUNK)</FONT>
      DO I = 1, N
         C(I) = A(I) + B(I)
      ENDDO
<FONT color=red>!$OMP END DO NOWAIT</FONT>

<FONT color=red>!$OMP END PARALLEL</FONT>

      END
</B></PRE></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - for Directive 
        Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;
#define CHUNKSIZE 100
#define N     1000

main ()  
{

int i, chunk;
float a[N], b[N], c[N];

/* Some initializations */
for (i=0; i &lt; N; i++)
  a[i] = b[i] = i * 1.0;
chunk = CHUNKSIZE;

<FONT color=red>#pragma omp parallel shared(a,b,c,chunk) private(i)</FONT>
  {

  <FONT color=red>#pragma omp for schedule(dynamic,chunk) nowait</FONT>
  for (i=0; i &lt; N; i++)
    c[i] = a[i] + b[i];

  }  /* end of parallel section */

}
</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=SECTIONS><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Work-Sharing Constructs <BR>SECTIONS Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The SECTIONS directive is a non-iterative work-sharing construct. It 
  specifies that the enclosed section(s) of code are to be divided among the 
  threads in the team. 
  <P></P>
  <LI>Independent SECTION directives are nested within a SECTIONS directive. 
  Each SECTION is executed once by a thread in the team. Different sections may 
  be executed by different threads. It is possible that for a thread to execute 
  more than one section if it is quick enough and the implementation permits 
  such. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP SECTIONS <I>[clause ...] </I>
               PRIVATE <I>(list) </I>
               FIRSTPRIVATE <I>(list) </I>
               LASTPRIVATE <I>(list) </I>
               REDUCTION <I>(operator | intrinsic : list) </I>

!$OMP  SECTION 

   <I>block</I>

!$OMP  SECTION 

    <I>block</I> 

!$OMP END SECTIONS  [ NOWAIT ]

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp sections <I>[clause ...]  newline </I>
                     private <I>(list) </I>
                     firstprivate <I>(list) </I>
                     lastprivate <I>(list) </I>
                     reduction <I>(operator: list) </I>
                     nowait
  {

  #pragma omp section   <I>newline </I>

     <I>structured_block</I>

  #pragma omp section   <I>newline </I>

     <I>structured_block</I>

  }
</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Clauses:</SPAN> 
<UL>
  <P>
  <LI>There is an implied barrier at the end of a SECTIONS directive, unless the 
  <TT>NOWAIT/nowait</TT> clause is used. 
  <P></P>
  <LI>Clauses are described in detail later, in the <A 
  href="https://computing.llnl.gov/tutorials/openMP/#Clauses">Data Scope 
  Attribute Clauses</A> section. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Questions:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=0 border=0>
    <TBODY>
    <TR vAlign=top>
      <TD width=40><IMG height=39 src="OpenMP.files/question2.gif" width=29> 
      <TD>What happens if the number of threads and the number of SECTIONs are 
        different? More threads than SECTIONs? Less threads than SECTIONs? <BR><INPUT onclick="Answers('openMP01')" type=button value=Answer> 
    <TR>
      <TD>&nbsp; 
    <TR vAlign=top>
      <TD width=40><IMG height=39 src="OpenMP.files/question2.gif" width=29> 
      <TD>Which thread executes which SECTION? <BR><INPUT onclick="Answers('openMP02')" type=button value=Answer> 
    </TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to branch into or out of section blocks. 
  <P></P>
  <LI>SECTION directives must occur within the lexical extent of an enclosing 
  SECTIONS directive </LI></UL>
<P>
<HR>

<P>
<H2>Example: SECTIONS Directive</H2>
<UL>
  <P>
  <LI>Simple program demonstrating that different blocks of work will be done by 
  different threads. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - SECTIONS Directive 
        Example</SPAN> 
        <HR>
<PRE>      PROGRAM VEC_ADD_SECTIONS

      INTEGER N, I
      PARAMETER (N=1000)
      REAL A(N), B(N), C(N), D(N)

!     Some initializations
      DO I = 1, N
        A(I) = I * 1.5
        B(I) = I + 22.35
      ENDDO

<FONT color=red>!$OMP PARALLEL SHARED(A,B,C,D), PRIVATE(I)</FONT>

<FONT color=red>!$OMP SECTIONS</FONT>

<FONT color=red>!$OMP SECTION</FONT>
      DO I = 1, N
         C(I) = A(I) + B(I)
      ENDDO

<FONT color=red>!$OMP SECTION</FONT>
      DO I = 1, N
         D(I) = A(I) * B(I)
      ENDDO

<FONT color=red>!$OMP END SECTIONS NOWAIT</FONT>

<FONT color=red>!$OMP END PARALLEL</FONT>

      END
</B></PRE></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - sections Directive 
        Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;
#define N     1000

main ()
{

int i;
float a[N], b[N], c[N], d[N];

/* Some initializations */
for (i=0; i &lt; N; i++)
  a[i] = i * 1.5;
  b[i] = i + 22.35;

<FONT color=red>#pragma omp parallel shared(a,b,c,d) private(i)</FONT>
  {

  <FONT color=red>#pragma omp sections nowait</FONT>
    {

    <FONT color=red>#pragma omp section</FONT>
    for (i=0; i &lt; N; i++)
      c[i] = a[i] + b[i];

    <FONT color=red>#pragma omp section</FONT>
    for (i=0; i &lt; N; i++)
      d[i] = a[i] * b[i];

    }  /* end of sections */

  }  /* end of parallel section */

}
</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=WORKSHARE><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Work-Sharing Constructs <BR>WORKSHARE Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Fortran only 
  <P></P>
  <LI>The WORKSHARE directive divides the execution of the enclosed structured 
  block into separate units of work, each of which is executed only once. 
  <P></P>
  <LI>The structured block must consist of only the following: 
  <UL>
    <LI>array assignments 
    <LI>scalar assignments 
    <LI>FORALL statements 
    <LI>FORALL constructs 
    <LI>WHERE statements 
    <LI>WHERE constructs 
    <LI>atomic constructs 
    <LI>critical constructs 
    <LI>parallel constructs </LI></UL>
  <P></P>
  <LI>See the OpenMP API documentation for additional information. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP WORKSHARE

   <I>structured block</I>

!$OMP END WORKSHARE [ NOWAIT ]

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>The construct must not contain any user defined function calls unless the 
  function is ELEMENTAL. </LI></UL>
<P>
<HR>

<P>
<H2>Example: WORKSHARE Directive</H2>
<UL>
  <P>
  <LI>Simple array and scalar assigments shared by the team of threads. A unit 
  of work would include: 
  <UL>
    <LI>Any scalar assignment 
    <LI>For array assignment statements, the assignment of each element is a 
    unit of work </LI></UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - WORKSHARE Directive 
        Example</SPAN> 
        <HR>
<PRE>      PROGRAM WORKSHARE
 
      INTEGER N, I, J
      PARAMETER (N=100)
      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N), FIRST, LAST
 
!     Some initializations
      DO I = 1, N
        DO J = 1, N
          AA(J,I) = I * 1.0
          BB(J,I) = J + 1.0
        ENDDO
      ENDDO
 
<FONT color=red>!$OMP PARALLEL SHARED(AA,BB,CC,DD,FIRST,LAST)</FONT>

<FONT color=red>!$OMP WORKSHARE</FONT>
      CC = AA * BB
      DD = AA + BB
      FIRST = CC(1,1) + DD(1,1)
      LAST = CC(N,N) + DD(N,N)
<FONT color=red>!$OMP END WORKSHARE NOWAIT</FONT>

<FONT color=red>!$OMP END PARALLEL</FONT>
 
      END
</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=SINGLE><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Work-Sharing Constructs <BR>SINGLE Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The SINGLE directive specifies that the enclosed code is to be executed by 
  only one thread in the team. 
  <P></P>
  <LI>May be useful when dealing with sections of code that are not thread safe 
  (such as I/O) </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP SINGLE <I>[clause ...] </I>
             PRIVATE <I>(list) </I>
             FIRSTPRIVATE <I>(list) </I>

   <I>block</I>

!$OMP END SINGLE [ NOWAIT ]

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp single <I>[clause ...]  newline </I>
                   private <I>(list) </I>
                   firstprivate <I>(list) </I>
                   nowait

     <I>structured_block</I>

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Clauses:</SPAN> 
<UL>
  <P>
  <LI>Threads in the team that do not execute the SINGLE directive, wait at the 
  end of the enclosed code block, unless a <TT>NOWAIT/nowait</TT> clause is 
  specified. 
  <P></P>
  <LI>Clauses are described in detail later, in the <A 
  href="https://computing.llnl.gov/tutorials/openMP/#Clauses">Data Scope 
  Attribute Clauses</A> section. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to branch into or out of a SINGLE block. </LI></UL><!--------------------------------------------------------------------------><A 
name=Combined><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Combined Parallel Work-Sharing Constructs </H2>
<UL>
  <P>
  <LI>OpenMP provides three directives that are merely conveniences: 
  <UL>
    <LI>PARALLEL DO / parallel for 
    <LI>PARALLEL SECTIONS 
    <LI>PARALLEL WORKSHARE (fortran only) </LI></UL>
  <P></P>
  <LI>For the most part, these directives behave identically to an individual 
  PARALLEL directive being immediately followed by a separate work-sharing 
  directive. 
  <P></P>
  <LI>Most of the rules, clauses and restrictions that apply to both directives 
  are in effect. See the OpenMP API for details. 
  <P></P>
  <LI>An example using the PARALLEL DO / parallel for combined directive is 
  shown below. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - PARALLEL DO Directive 
        Example</SPAN> 
        <HR>
<PRE>      PROGRAM VECTOR_ADD

      INTEGER N, I, CHUNKSIZE, CHUNK
      PARAMETER (N=1000) 
      PARAMETER (CHUNKSIZE=100) 
      REAL A(N), B(N), C(N)

!     Some initializations
      DO I = 1, N
        A(I) = I * 1.0
        B(I) = A(I)
      ENDDO
      CHUNK = CHUNKSIZE
             
<FONT color=red>!$OMP PARALLEL DO
!$OMP&amp; SHARED(A,B,C,CHUNK) PRIVATE(I) 
!$OMP&amp; SCHEDULE(STATIC,CHUNK)</FONT>

      DO I = 1, N
         C(I) = A(I) + B(I)
      ENDDO

<FONT color=red>!$OMP END PARALLEL DO</FONT>

      END
</B></PRE></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - parallel for 
        Directive Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;
#define N       1000
#define CHUNKSIZE   100

main ()  {

int i, chunk;
float a[N], b[N], c[N];

/* Some initializations */
for (i=0; i &lt; N; i++)
  a[i] = b[i] = i * 1.0;
chunk = CHUNKSIZE;

<FONT color=red>#pragma omp parallel for \
   shared(a,b,c,chunk) private(i) \
   schedule(static,chunk)</FONT>
  for (i=0; i &lt; n; i++)
    c[i] = a[i] + b[i];
}

</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=Synchronization><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs</H2>
<UL>
  <P>
  <LI>Consider a simple example where two threads on two different processors 
  are both trying to increment a variable x at the same time (assume x is 
  initially 0): 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR vAlign=top>
      <TD><B>THREAD 1:</B> <PRE>increment(x)
{
    x = x + 1;
}
</PRE><B>THREAD 1:</B> <PRE>10  LOAD A, (x address)
20  ADD A, 1
30  STORE A, (x address)
</PRE>
      <TD><B>THREAD 2:</B> <PRE>increment(x)
{
    x = x + 1;
}
</PRE><B>THREAD 2:</B> <PRE>10  LOAD A, (x address)
20  ADD A, 1
30  STORE A, (x address)
</PRE></TD></TR></TBODY></TABLE>
  <P></P>
  <LI>One possible execution sequence: 
  <OL>
    <LI>Thread 1 loads the value of x into register A. 
    <LI>Thread 2 loads the value of x into register A. 
    <LI>Thread 1 adds 1 to register A 
    <LI>Thread 2 adds 1 to register A 
    <LI>Thread 1 stores register A at location x 
    <LI>Thread 2 stores register A at location x </LI></OL>
  <P>The resultant value of x will be 1, not 2 as it should be. 
  <P></P>
  <LI>To avoid a situation like this, the incrementation of x must be 
  synchronized between the two threads to insure that the correct result is 
  produced. 
  <P></P>
  <LI>OpenMP provides a variety of Synchronization Constructs that control how 
  the execution of each thread proceeds relative to other team threads. </LI></UL><!--------------------------------------------------------------------------><A 
name=MASTER><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>MASTER Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The MASTER directive specifies a region that is to be executed only by the 
  master thread of the team. All other threads on the team skip this section of 
  code 
  <P></P>
  <LI>There is no implied barrier associated with this directive </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP MASTER

   <I>block</I>

!$OMP END MASTER

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp master  <I>newline</I>

   <I>structured_block</I>

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to branch into or out of MASTER block. </LI></UL><!--------------------------------------------------------------------------><A 
name=CRITICAL><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>CRITICAL Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The CRITICAL directive specifies a region of code that must be executed by 
  only one thread at a time. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP CRITICAL <I>[ name ]</I>

   <I>block</I>

!$OMP END CRITICAL

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp critical <I>[ name ]  newline</I>

   <I>structured_block</I>

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>If a thread is currently executing inside a CRITICAL region and another 
  thread reaches that CRITICAL region and attempts to execute it, it will block 
  until the first thread exits that CRITICAL region. 
  <P></P>
  <LI>The optional name enables multiple different CRITICAL regions to exist: 
  <UL>
    <LI>Names act as global identifiers. Different CRITICAL regions with the 
    same name are treated as the same region. 
    <LI>All CRITICAL sections which are unnamed, are treated as the same 
    section. </LI></UL></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to branch into or out of a CRITICAL block. </LI></UL>
<P>
<HR>

<P>
<H2>Example: CRITICAL Construct</H2>
<UL>
  <P>
  <LI>All threads in the team will attempt to execute in parallel, however, 
  because of the CRITICAL construct surrounding the increment of x, only one 
  thread will be able to read/increment/write x at any time 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - CRITICAL Directive 
        Example</SPAN> 
        <HR>
<PRE>      PROGRAM CRITICAL

      INTEGER X
      X = 0

<FONT color=red>!$OMP PARALLEL SHARED(X) </FONT>

<FONT color=red>!$OMP CRITICAL </FONT>
      X = X + 1
<FONT color=red>!$OMP END CRITICAL </FONT>

<FONT color=red>!$OMP END PARALLEL </FONT>

      END
</B></PRE></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - critical Directive 
        Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;

main()
{

int x;
x = 0;

<FONT color=red>#pragma omp parallel shared(x) </FONT>
  {

<FONT color=red>  #pragma omp critical </FONT>
  x = x + 1;

  }  /* end of parallel section */

}
</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=BARRIER><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>BARRIER Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The BARRIER directive synchronizes all threads in the team. 
  <P></P>
  <LI>When a BARRIER directive is reached, a thread will wait at that point 
  until all other threads have reached that barrier. All threads then resume 
  executing in parallel the code that follows the barrier. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP BARRIER

</B></PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp barrier  <I>newline</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>All threads in a team (or none) must execute the BARRIER region. 
  <P></P>
  <LI>The sequence of work-sharing regions and barrier regions encountered must 
  be the same for every thread in a team. </LI></UL><!--------------------------------------------------------------------------><A 
name=ATOMIC><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>ATOMIC Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The ATOMIC directive specifies that a specific memory location must be 
  updated atomically, rather than letting multiple threads attempt to write to 
  it. In essence, this directive provides a mini-CRITICAL section. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP ATOMIC

   <I>statement_expression</I>

</PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp atomic  <I>newline</I>

   <I>statement_expression</I>

</PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>The directive applies only to a single, immediately following statement 
  <P></P>
  <LI>An atomic statement must follow a specific syntax. See the most recent 
  OpenMP specs for this. </LI></UL><!--------------------------------------------------------------------------><A 
name=FLUSH><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>FLUSH Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The FLUSH directive identifies a synchronization point at which the 
  implementation must provide a consistent view of memory. Thread-visible 
  variables are written back to memory at this point. 
  <P></P>
  <LI>There is a fair amount of discussion on this directive within OpenMP 
  circles that you may wish to consult for more information. 
  <P></P>
  <LI>To quote from the openmp.org FAQ: 
  <P><B>Q17:</B> Is the !$omp flush directive necessary on a cache coherent 
  system? 
  <P><I><B>A17:</B> Yes the flush directive is necessary. Look in the OpenMP 
  specifications for examples of it's uses. The directive is necessary to 
  instruct the compiler that the variable must be written to/read from the 
  memory system, i.e. that the variable can not be kept in a local CPU register 
  over the flush "statement" in your code. 
  <P>Cache coherency makes certain that if one CPU executes a read or write 
  instruction from/to memory, then all other CPUs in the system will get the 
  same value from that memory address when they access it. All caches will show 
  a coherent value. However, in the OpenMP standard there must be a way to 
  instruct the compiler to actually insert the read/write machine instruction 
  and not postpone it. Keeping a variable in a register in a loop is very common 
  when producing efficient machine language code for a loop. </I>
  <P></P>
  <LI>Also see the most recent OpenMP specs for details. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>!$OMP FLUSH  <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH>C/C++</TH>
      <TD><PRE>#pragma omp flush <I>(list)  newline</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>The optional list contains a list of named variables that will be flushed 
  in order to avoid flushing all variables. For pointers in the list, note that 
  the pointer itself is flushed, not the object it points to. 
  <P></P>
  <LI>Implementations must ensure any prior modifications to thread-visible 
  variables are visible to all threads after this point; ie. compilers must 
  restore values from registers to memory, hardware might need to flush write 
  buffers, etc 
  <P></P>
  <LI>The FLUSH directive is implied for the directives shown in the table 
  below. The directive is not implied if a NOWAIT clause is present. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR vAlign=top>
      <TH>Fortran</TH>
      <TH>C / C++</TH></TR>
    <TR vAlign=top>
      <TD>
        <UL>BARRIER <BR>END PARALLEL <BR>CRITICAL and END CRITICAL <BR>END DO 
          <BR>END SECTIONS <BR>END SINGLE <BR>ORDERED and END ORDERED </UL></TD>
      <TD>
        <UL><TT>barrier</TT> <BR><TT>parallel</TT> - upon entry and exit 
          <BR><TT>critical</TT> - upon entry and exit <BR><TT>ordered</TT> - 
          upon entry and exit <BR><TT>for</TT> - upon exit <BR><TT>sections</TT> 
          - upon exit <BR><TT>single</TT> - upon exit 
  <BR></UL></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=ORDERED><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Synchronization Constructs <BR>ORDERED Directive</H2><IMG hspace=3 
src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The ORDERED directive specifies that iterations of the enclosed loop will 
  be executed in the same order as if they were executed on a serial processor. 
  <P></P>
  <LI>Threads will need to wait before executing their chunk of iterations if 
  previous iterations haven't completed yet. 
  <P></P>
  <LI>Used within a DO / for loop with an ORDERED clause 
  <P></P>
  <LI>The ORDERED directive provides a way to "fine tune" where ordering is to 
  be applied within a loop. Otherwise, it is not required. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%" bgColor=#eeeeee>Fortran 
      <TD><PRE>!$OMP DO ORDERED <I>[clauses...]</I>
   <I>(loop region)</I>

!$OMP ORDERED

   <I>(block)</I>

!$OMP END ORDERED

   <I>(end of loop region)</I>
!$OMP END DO

</B></PRE></TD></TR>
    <TR>
      <TH bgColor=#eeeeee>C/C++ 
      <TD><PRE>#pragma omp for ordered <I>[clauses...]</I>
   <I>(loop region)</I>

#pragma omp ordered  <I>newline</I>

   <I>structured_block</I>

   <I>(endo of loop region)</I>
</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>An ORDERED directive can only appear in the dynamic extent of the 
  following directives: 
  <UL>
    <LI>DO or PARALLEL DO (Fortran) 
    <LI><TT>for</TT> or <TT>parallel for</TT> (C/C++) </LI></UL>
  <P></P>
  <LI>Only one thread is allowed in an ordered section at any time 
  <P></P>
  <LI>It is illegal to branch into or out of an ORDERED block. 
  <P></P>
  <LI>An iteration of a loop must not execute the same ORDERED directive more 
  than once, and it must not execute more than one ORDERED directive. 
  <P></P>
  <LI>A loop which contains an ORDERED directive, must be a loop with an ORDERED 
  clause. </LI></UL><!--------------------------------------------------------------------------><A 
name=THREADPRIVATE><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>THREADPRIVATE Directive</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The THREADPRIVATE directive is used to make global file scope variables 
  (C/C++) or common blocks (Fortran) local and persistent to a thread through 
  the execution of multiple parallel regions. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%" bgColor=#eeeeee>Fortran 
      <TD><PRE>!$OMP THREADPRIVATE (/cb/, ...)  </B><I>cb is the name of a common block

</B></PRE></I></TD></TR>
    <TR>
      <TH width="5%" bgColor=#eeeeee>C/C++ 
      <TD><PRE>#pragma omp threadprivate <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>The directive must appear after the declaration of listed variables/common 
  blocks. Each thread then gets its own copy of the variable/common block, so 
  data written by one thread is not visible to other threads. For example: <A 
  name=ThreadprivateExamples></A>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - THREADPRIVATE 
        Directive Example</SPAN> 
        <HR>
<PRE>      PROGRAM THREADPRIV
 
      INTEGER A, B, I, TID, OMP_GET_THREAD_NUM
      REAL*4 X
      COMMON /C1/ A
 
<FONT color=red>!$OMP THREADPRIVATE(/C1/, X) </FONT>
 
C     Explicitly turn off dynamic threads
<FONT color=red>      CALL OMP_SET_DYNAMIC(.FALSE.)</FONT>
 
      PRINT *, '1st Parallel Region:'
<FONT color=red>!$OMP PARALLEL PRIVATE(B, TID) </FONT>
      TID = OMP_GET_THREAD_NUM()
      A = TID
      B = TID
      X = 1.1 * TID + 1.0
      PRINT *, 'Thread',TID,':   A,B,X=',A,B,X
<FONT color=red>!$OMP END PARALLEL </FONT>
 
      PRINT *, '************************************'
      PRINT *, 'Master thread doing serial work here'
      PRINT *, '************************************'
 
      PRINT *, '2nd Parallel Region: '
<FONT color=red>!$OMP PARALLEL PRIVATE(TID) </FONT>
      TID = OMP_GET_THREAD_NUM()
      PRINT *, 'Thread',TID,':   A,B,X=',A,B,X
<FONT color=red>!$OMP END PARALLEL </FONT>
 
      END
<P><HR>Output:

 1st Parallel Region:
 Thread 0 :   A,B,X= 0 0 1.000000000
 Thread 1 :   A,B,X= 1 1 2.099999905
 Thread 3 :   A,B,X= 3 3 4.300000191
 Thread 2 :   A,B,X= 2 2 3.200000048
 ************************************
 Master thread doing serial work here
 ************************************
 2nd Parallel Region: 
 Thread 0 :   A,B,X= 0 0 1.000000000
 Thread 2 :   A,B,X= 2 0 3.200000048
 Thread 3 :   A,B,X= 3 0 4.300000191
 Thread 1 :   A,B,X= 1 0 2.099999905

</B></PRE></FONT></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C/C++ - threadprivate Directive 
        Example</SPAN> 
        <HR>
<PRE><FONT color=red>#include &lt;omp.h&gt; </FONT>
 
int  a, b, i, tid;
float x;
 
<FONT color=red>#pragma omp threadprivate(a, x)</FONT>
 
main ()  {
 
/* Explicitly turn off dynamic threads */
<FONT color=red>  omp_set_dynamic(0);</FONT>
 
  printf("1st Parallel Region:\n");
<FONT color=red>#pragma omp parallel private(b,tid)</FONT>
  {
  tid = omp_get_thread_num();
  a = tid;
  b = tid;
  x = 1.1 * tid +1.0;
  printf("Thread %d:   a,b,x= %d %d %f\n",tid,a,b,x);
  }  /* end of parallel section */
 
  printf("************************************\n");
  printf("Master thread doing serial work here\n");
  printf("************************************\n");
 
  printf("2nd Parallel Region:\n");
<FONT color=red>#pragma omp parallel private(tid)</FONT>
  {
  tid = omp_get_thread_num();
  printf("Thread %d:   a,b,x= %d %d %f\n",tid,a,b,x);
  }  /* end of parallel section */

}

<P><HR>Output:

1st Parallel Region:
Thread 0:   a,b,x= 0 0 1.000000
Thread 2:   a,b,x= 2 2 3.200000
Thread 3:   a,b,x= 3 3 4.300000
Thread 1:   a,b,x= 1 1 2.100000
************************************
Master thread doing serial work here
************************************
2nd Parallel Region:
Thread 0:   a,b,x= 0 0 1.000000
Thread 3:   a,b,x= 3 0 4.300000
Thread 1:   a,b,x= 1 0 2.100000
Thread 2:   a,b,x= 2 0 3.200000

</B></PRE></FONT></TD></TR></TBODY></TABLE>
  <P></P>
  <LI>On first entry to a parallel region, data in THREADPRIVATE variables and 
  common blocks should be assumed undefined, unless a COPYIN clause is specified 
  in the PARALLEL directive 
  <P></P>
  <LI>THREADPRIVATE variables differ from PRIVATE variables (discussed later) 
  because they are able to persist between different parallel sections of a 
  code. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Data in THREADPRIVATE objects is guaranteed to persist only if the dynamic 
  threads mechanism is "turned off" and the number of threads in different 
  parallel regions remains constant. The default setting of dynamic threads is 
  undefined. 
  <P></P>
  <LI>The THREADPRIVATE directive must appear after every declaration of a 
  thread private variable/common block. 
  <P></P>
  <LI>Fortran: only named common blocks can be made THREADPRIVATE. </LI></UL><!--------------------------------------------------------------------------><A 
name=Clauses><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Data Scope Attribute Clauses</H2>
<UL>
  <P>
  <LI>An important consideration for OpenMP programming is the understanding and 
  use of data scoping 
  <P></P>
  <LI>Because OpenMP is based upon the shared memory programming model, most 
  variables are shared by default 
  <P></P>
  <LI>Global variables include: 
  <UL>
    <LI>Fortran: COMMON blocks, SAVE variables, MODULE variables 
    <LI>C: File scope variables, static </LI></UL>
  <P></P>
  <LI>Private variables include: 
  <UL>
    <LI>Loop index variables 
    <LI>Stack variables in subroutines called from parallel regions 
    <LI>Fortran: Automatic variables within a statement block </LI></UL>
  <P></P>
  <LI>The OpenMP Data Scope Attribute Clauses are used to explicitly define how 
  variables should be scoped. They include: 
  <UL>
    <LI>PRIVATE 
    <LI>FIRSTPRIVATE 
    <LI>LASTPRIVATE 
    <LI>SHARED 
    <LI>DEFAULT 
    <LI>REDUCTION 
    <LI>COPYIN </LI></UL>
  <P></P>
  <LI>Data Scope Attribute Clauses are used in conjunction with several 
  directives (PARALLEL, DO/for, and SECTIONS) to control the scoping of enclosed 
  variables. 
  <P></P>
  <LI>These constructs provide the ability to control the data environment 
  during execution of parallel constructs. 
  <UL>
    <P>
    <LI>They define how and which data variables in the serial section of the 
    program are transferred to the parallel sections of the program (and back) 
    <P></P>
    <LI>They define which variables will be visible to all threads in the 
    parallel sections and which variables will be privately allocated to all 
    threads. </LI></UL>
  <P></P>
  <LI><B>Note:</B> Data Scope Attribute Clauses are effective only within their 
  lexical/static extent. 
  <P></P>
  <LI>See the <A 
  href="https://computing.llnl.gov/tutorials/openMP/#ClausesDirectives">Clauses 
  / Directives Summary Table</A> for the associations between directives and 
  clauses. </LI></UL>
<P>
<HR>

<P><A name=PRIVATE></A>
<H2>PRIVATE Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The PRIVATE clause declares variables in its list to be private to each 
  thread. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>PRIVATE <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>private <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>PRIVATE variables behave as follows: 
  <UL>
    <P>
    <LI>A new object of the same type is declared once for each thread in the 
    team 
    <P></P>
    <LI>All references to the original object are replaced with references to 
    the new object 
    <P></P>
    <LI>Variables declared PRIVATE are uninitialized for each thread </LI></UL>
  <P></P>
  <LI>Comparison between PRIVATE and THREADPRIVATE: 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR vAlign=top>
      <TH>&nbsp;</TH>
      <TH>PRIVATE</TH>
      <TH>THREADPRIVATE</TH></TR>
    <TR vAlign=top>
      <TD>Data Item</TD>
      <TD>C/C++: variable <BR>Fortran: variable or common block</TD>
      <TD>C/C++: variable <BR>Fortran: common block</TD></TR>
    <TR vAlign=top>
      <TD>Where Declared</TD>
      <TD>At start of region or work-sharing group</TD>
      <TD>In declarations of each routine using block or global file 
    scope</TD></TR>
    <TR vAlign=top>
      <TD>Persistent?</TD>
      <TD>No</TD>
      <TD>Yes</TD></TR>
    <TR vAlign=top>
      <TD>Extent</TD>
      <TD>Lexical only - unless passed as an argument to subroutine </TD>
      <TD>Dynamic</TD></TR>
    <TR vAlign=top>
      <TD>Initialized</TD>
      <TD>Use FIRSTPRIVATE</TD>
      <TD>Use COPYIN </TD></TR></TBODY></TABLE></P></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Questions:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=0 border=0>
    <TBODY>
    <TR vAlign=top>
      <TD width=40><IMG height=39 src="OpenMP.files/question2.gif" width=29> 
      <TD>For the C/C++ and Fortran <A 
        href="https://computing.llnl.gov/tutorials/openMP/#ThreadprivateExamples">THREADPRIVATE 
        example codes</A>, what output would you expect for alpha[3] and 
        beta[3]? Why? <BR><INPUT onclick="Answers('openMP03')" type=button value=Answer> 
    </TD></TR></TBODY></TABLE></P></UL><A name=SHARED></A>
<P>
<HR>

<P>
<H2>SHARED Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The SHARED clause declares variables in its list to be shared among all 
  threads in the team. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SHARED <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>shared <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>A shared variable exists in only one memory location and all threads can 
  read or write to that address 
  <P></P>
  <LI>It is the programmer's responsibility to ensure that multiple threads 
  properly access SHARED variables (such as via CRITICAL sections) </LI></UL><A 
name=DEFAULT></A>
<P>
<HR>

<P>
<H2>DEFAULT Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The DEFAULT clause allows the user to specify a default PRIVATE, SHARED, 
  or NONE scope for all variables in the lexical extent of any parallel region. 
  </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TD> 
      <TD><PRE>DEFAULT (PRIVATE | SHARED | NONE)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TD> 
      <TD><PRE>default (shared | none)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>Specific variables can be exempted from the default using the PRIVATE, 
  SHARED, FIRSTPRIVATE, LASTPRIVATE, and REDUCTION clauses 
  <P></P>
  <LI>The C/C++ OpenMP specification does not include "private" as a possible 
  default. However, actual implementations may provide this option. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Only one DEFAULT clause can be specified on a PARALLEL directive 
</LI></UL><A name=FIRSTPRIVATE></A>
<P>
<HR>

<P>
<H2>FIRSTPRIVATE Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The FIRSTPRIVATE clause combines the behavior of the PRIVATE clause with 
  automatic initialization of the variables in its list. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TD> 
      <TD><PRE>FIRSTPRIVATE <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TD> 
      <TD><PRE>firstprivate <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>Listed variables are initialized according to the value of their original 
  objects prior to entry into the parallel or work-sharing construct. </LI></UL><A 
name=LASTPRIVATE></A>
<P>
<HR>

<P>
<H2>LASTPRIVATE Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The LASTPRIVATE clause combines the behavior of the PRIVATE clause with a 
  copy from the last loop iteration or section to the original variable object. 
  </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>LASTPRIVATE <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>lastprivate <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>The value copied back into the original variable object is obtained from 
  the last (sequentially) iteration or section of the enclosing construct. 
  <P>For example, the team member which executes the final iteration for a DO 
  section, or the team member which does the last SECTION of a SECTIONS context 
  performs the copy with its own values </P></LI></UL><A name=COPYIN></A>
<P>
<HR>

<P>
<H2>COPYIN Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The COPYIN clause provides a means for assigning the same value to 
  THREADPRIVATE variables for all threads in the team. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>COPYIN <I>(list)</I>

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TD> 
      <TD><PRE>copyin  <I>(list)</I>

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes:</SPAN> 
<UL>
  <P>
  <LI>List contains the names of variables to copy. In Fortran, the list can 
  contain both the names of common blocks and named variables. 
  <P></P>
  <LI>The master thread variable is used as the copy source. The team threads 
  are initialized with its value upon entry into the parallel construct. 
</LI></UL><A name=REDUCTION></A>
<P>
<HR>

<P>
<H2>REDUCTION Clause</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>The REDUCTION clause performs a reduction on the variables that appear in 
  its list. 
  <P></P>
  <LI>A private copy for each list variable is created for each thread. At the 
  end of the reduction, the reduction variable is applied to all private copies 
  of the shared variable, and the final result is written to the global shared 
  variable. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>REDUCTION <I>(operator|intrinsic: list)</I>

</B></PRE></TD>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>reduction <I>(operator: list)</I>
</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Example: REDUCTION - Vector Dot Product:</SPAN> 
<UL>
  <P>
  <LI>Iterations of the parallel loop will be distributed in equal sized blocks 
  to each thread in the team (SCHEDULE STATIC) 
  <P></P>
  <LI>At the end of the parallel loop construct, all threads will add their 
  values of "result" to update the master thread's global copy. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - REDUCTION Clause 
        Example</SPAN> 
        <HR>
<PRE>       PROGRAM DOT_PRODUCT

       INTEGER N, CHUNKSIZE, CHUNK, I
       PARAMETER (N=100)
       PARAMETER (CHUNKSIZE=10)
       REAL A(N), B(N), RESULT

!      Some initializations
       DO I = 1, N
         A(I) = I * 1.0
         B(I) = I * 2.0
       ENDDO
       RESULT= 0.0
       CHUNK = CHUNKSIZE

<FONT color=red>!$OMP  PARALLEL DO</FONT>
<FONT color=red>!$OMP&amp; DEFAULT(SHARED) PRIVATE(I)</FONT>
<FONT color=red>!$OMP&amp; SCHEDULE(STATIC,CHUNK)</FONT>
<FONT color=red>!$OMP&amp; REDUCTION(+:RESULT)</FONT>

       DO I = 1, N
         RESULT = RESULT + (A(I) * B(I))
       ENDDO

<FONT color=red>!$OMP  END PARALLEL DO NOWAIT</FONT>

       PRINT *, 'Final Result= ', RESULT
       END
</B></PRE></FONT></TD></TR></TBODY></TABLE>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>C / C++ - reduction Clause 
        Example</SPAN> 
        <HR>
<PRE>#include &lt;omp.h&gt;

main ()  {

int   i, n, chunk;
float a[100], b[100], result;

/* Some initializations */
n = 100;
chunk = 10;
result = 0.0;
for (i=0; i &lt; n; i++)
  {
  a[i] = i * 1.0;
  b[i] = i * 2.0;
  }

<FONT color=red>#pragma omp parallel for      \  </FONT>
<FONT color=red>  default(shared) private(i)  \  </FONT>
<FONT color=red>  schedule(static,chunk)      \  </FONT>
<FONT color=red>  reduction(+:result)  </FONT>

  for (i=0; i &lt; n; i++)
    result = result + (a[i] * b[i]);

printf("Final result= %f\n",result);

}
</B></PRE></FONT></TR></TBODY></TABLE></P></LI></UL>
<UL></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Variables in the list must be named scalar variables. They can not be 
  array or structure type variables. They must also be declared SHARED in the 
  enclosing context. 
  <P></P>
  <LI>Reduction operations may not be associative for real numbers. 
  <P></P>
  <LI>The REDUCTION clause is intended to be used on a region or work-sharing 
  construct in which the reduction variable is used only in statements which 
  have one of following forms: 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH>Fortran</TH>
      <TH>C / C++</TH></TR>
    <TR vAlign=top>
      <TD><I><B>
        <UL>x = x operator expr <BR>x = expr operator x </B>(except 
          subtraction)<B> <BR>x = intrinsic(x, expr) <BR>x = intrinsic(expr, x) 
          </I></B></UL></TD>
      <TD><I><B>
        <UL>x = x op expr <BR>x = expr op x </B>(except subtraction)<B> <BR>x 
          binop = expr <BR>x++ <BR>++x <BR>x-- <BR>--x </I></B></UL></TD></TR>
    <TR vAlign=top>
      <TD><I><B>x</B></I> is a scalar variable in the list 
        <BR><I><B>expr</B></I> is a scalar expression that does not reference 
        <I><B>x</B></I> <BR><I><B>intrinsic</B></I> is one of MAX, MIN, IAND, 
        IOR, IEOR <BR><I><B>operator</B></I> is one of +, *, -, .AND., .OR., 
        .EQV., .NEQV. </TD>
      <TD><I><B>x</B></I> is a scalar variable in the list 
        <BR><I><B>expr</B></I> is a scalar expression that does not reference 
        <I><B>x</B></I> <BR><I><B>op</B></I> is not overloaded, and is one of +, 
        *, -, /, &amp;, ^, |, &amp;&amp;, || <BR><I><B>binop</B></I> is not 
        overloaded, and is one of +, *, -, /, &amp;, ^, | 
  </TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=ClausesDirectives><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Clauses / Directives Summary</H2>
<UL>
  <P>
  <LI>The table below summarizes which clauses are accepted by which OpenMP 
  directives. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 border=1>
    <TBODY>
    <TR>
      <TH rowSpan=2>Clause</TH>
      <TH colSpan=6>Directive</TH>
    <TR vAlign=top>
      <TH>PARALLEL</TH>
      <TH>DO/for</TH>
      <TH>SECTIONS</TH>
      <TH>SINGLE</TH>
      <TH>PARALLEL <BR>DO/for</TH>
      <TH>PARALLEL <BR>SECTIONS</TH>
    <TR align=middle>
      <TD align=left><FONT size=-1><B>IF</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>PRIVATE</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>SHARED</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>DEFAULT</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>FIRSTPRIVATE</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>LASTPRIVATE</B></FONT> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>REDUCTION</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>COPYIN</B></FONT> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>SCHEDULE</B></FONT> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>ORDERED</B></FONT> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
    <TR align=middle>
      <TD align=left><FONT size=-1><B>NOWAIT</B></FONT> 
      <TD>&nbsp; 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD><IMG height=14 src="OpenMP.files/ball_red.gif" width=14 border=0> 
      <TD>&nbsp; 
      <TD>&nbsp; </TR></TBODY></TABLE>
  <P></P>
  <LI>The following OpenMP directives do not accept clauses: 
  <UL>
    <LI>MASTER 
    <LI>CRITICAL 
    <LI>BARRIER 
    <LI>ATOMIC 
    <LI>FLUSH 
    <LI>ORDERED 
    <LI>THREADPRIVATE </LI></UL>
  <P></P>
  <LI>Implementations may (and do) differ from the standard in which clauses are 
  supported by each directive. </LI></UL><!--------------------------------------------------------------------------><A 
name=BindingNesting><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>OpenMP Directives</SPAN> 
  </TD></TR></TBODY></TABLE>
<H2>Directive Binding and Nesting Rules</H2>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD width=40><IMG height=34 alt=Note src="OpenMP.files/note02.gif" 
      width=34 border=0> 
    <TD>This section is provided mainly as a quick reference on rules which 
      govern OpenMP directives and binding. Users should consult their 
      implementation documentation and the OpenMP standard for other rules and 
      restrictions. </TD></TR></TBODY></TABLE>
<UL>
  <P>
  <LI>Unless indicated otherwise, rules apply to both Fortran and C/C++ OpenMP 
  implementations. 
  <P></P>
  <LI>Note: the Fortran API also defines a number of Data Environment rules. 
  Those have not been reproduced here. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Directive Binding:</SPAN> 
<UL>
  <P>
  <LI>The DO/for, SECTIONS, SINGLE, MASTER and BARRIER directives bind to the 
  dynamically enclosing PARALLEL, if one exists. If no parallel region is 
  currently being executed, the directives have no effect. 
  <P></P>
  <LI>The ORDERED directive binds to the dynamically enclosing DO/for. 
  <P></P>
  <LI>The ATOMIC directive enforces exclusive access with respect to ATOMIC 
  directives in all threads, not just the current team. 
  <P></P>
  <LI>The CRITICAL directive enforces exclusive access with respect to CRITICAL 
  directives in all threads, not just the current team. 
  <P></P>
  <LI>A directive can never bind to any directive outside the closest enclosing 
  PARALLEL. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Directive Nesting:</SPAN> 
<UL>
  <P>
  <LI>A PARALLEL directive dynamically inside another PARALLEL directive 
  logically establishes a new team, which is composed of only the current thread 
  unless nested parallelism is enabled. 
  <P></P>
  <LI>DO/for, SECTIONS, and SINGLE directives that bind to the same PARALLEL are 
  not allowed to be nested inside of each other. 
  <P></P>
  <LI>DO/for, SECTIONS, and SINGLE directives are not permitted in the dynamic 
  extent of CRITICAL, ORDERED and MASTER regions. 
  <P></P>
  <LI>CRITICAL directives with the same name are not permitted to be nested 
  inside of each other. 
  <P></P>
  <LI>BARRIER directives are not permitted in the dynamic extent of DO/for, 
  ORDERED, SECTIONS, SINGLE, MASTER and CRITICAL regions. 
  <P></P>
  <LI>MASTER directives are not permitted in the dynamic extent of DO/for, 
  SECTIONS and SINGLE directives. 
  <P></P>
  <LI>ORDERED directives are not permitted in the dynamic extent of CRITICAL 
  regions. 
  <P></P>
  <LI>Any directive that is permitted when executed dynamically inside a 
  PARALLEL region is also legal when executed outside a parallel region. When 
  executed dynamically outside a user-specified parallel region, the directive 
  is executed with respect to a team composed of only the master thread. 
</LI></UL><!--------------------------------------------------------------------------><A 
name=RunTimeLibrary><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>Run-Time Library Routines</SPAN> 
    </TD></TR></TBODY></TABLE>
<P><BR><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Overview:</SPAN> 
<UL>
  <P>
  <LI>The OpenMP standard defines an API for library calls that perform a 
  variety of functions: 
  <UL>
    <P>
    <LI>Query the number of threads/processors, set number of threads to use 
    <P></P>
    <LI>General purpose locking routines (semaphores) 
    <P></P>
    <LI>Portable wall clock timing routines 
    <P></P>
    <LI>Set execution environment functions: nested parallelism, dynamic 
    adjustment of threads. 
    <P></P></LI></UL>
  <P></P>
  <LI>For C/C++, it may be necessary to specify the include file "omp.h". 
  <P></P>
  <LI>For the Lock routines/functions: 
  <UL>
    <P>
    <LI>The lock variable must be accessed only through the locking routines 
    <P></P>
    <LI>For Fortran, the lock variable should be of type integer and of a kind 
    large enough to hold an address. 
    <P></P>
    <LI>For C/C++, the lock variable must have type <TT>omp_lock_t</TT> or type 
    <TT>omp_nest_lock_t</TT>, depending on the function being used. </LI></UL>
  <P></P>
  <LI>Implementation notes: 
  <UL>
    <P>
    <LI>Your implementation may or may not support nested parallelism and/or 
    dynamic threads. If nested parallelism is supported, it is often only 
    nominal, in that a nested parallel region may only have one thread. 
    <P></P>
    <LI>Consult your implementation's documentation for details - or experiment 
    and find out for yourself if you can't find it in the documentation. 
  </LI></UL></TD></TR></TABLE></LI></UL>
<P>
<HR>

<P><A name=OMP_SET_NUM_THREADS></A>
<H2>OMP_SET_NUM_THREADS</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Sets the number of threads that will be used in the next parallel region. 
  Must be a postive integer. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_SET_NUM_THREADS(scalar_integer_expression)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
void omp_set_num_threads(int num_threads)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>The dynamic threads mechanism modifies the effect of this routine. 
  <UL>
    <LI>Enabled: specifies the maximum number of threads that can be used for 
    any parallel region by the dynamic threads mechanism. 
    <LI>Disabled: specifies exact number of threads to use until next call to 
    this routine. </LI></UL>
  <P></P>
  <LI>This routine can only be called from the serial portions of the code 
  <P></P>
  <LI>This call has precedence over the OMP_NUM_THREADS environment variable 
  </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_NUM_THREADS></A>
<H2>OMP_GET_NUM_THREADS</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Returns the number of threads that are currently in the team executing the 
  parallel region from which it is called. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>INTEGER FUNCTION OMP_GET_NUM_THREADS()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_num_threads(void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>If this call is made from a serial portion of the program, or a nested 
  parallel region that is serialized, it will return 1. 
  <P></P>
  <LI>The default number of threads is implementation dependent. </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_MAX_THREADS></A>
<H2>OMP_GET_MAX_THREADS</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Returns the maximum value that can be returned by a call to the 
  OMP_GET_NUM_THREADS function. 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>INTEGER FUNCTION OMP_GET_MAX_THREADS()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_max_threads(void)

</B></PRE></TD></TR></TBODY></TABLE></P></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Generally reflects the number of threads as set by the OMP_NUM_THREADS 
  environment variable or the OMP_SET_NUM_THREADS() library routine. 
  <P></P>
  <LI>May be called from both serial and parallel regions of code. </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_THREAD_NUM></A>
<H2>OMP_GET_THREAD_NUM</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Returns the thread number of the thread, within the team, making this 
  call. This number will be between 0 and OMP_GET_NUM_THREADS-1. The master 
  thread of the team is thread 0 </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>INTEGER FUNCTION OMP_GET_THREAD_NUM()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_thread_num(void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>If called from a nested parallel region, or a serial region, this function 
  will return 0. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Examples:</SPAN> 
<UL>
  <LI>Example 1 is the correct way to determine the number of threads in a 
  parallel region. 
  <LI>Example 2 is incorrect - the TID variable must be PRIVATE 
  <LI>Example 3 is incorrect - the OMP_GET_THREAD_NUM call is outside the 
  parallel region 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TD bgColor=#eeeeee><IMG height=22 src="OpenMP.files/page01.gif" 
        width=20 align=top> <SPAN class=heading3>Fortran - determining the 
        number of threads in a parallel region</SPAN> 
        <HR>
        Example 1: Correct <PRE>      PROGRAM HELLO

      INTEGER TID, OMP_GET_THREAD_NUM

!$OMP PARALLEL PRIVATE(TID)

      TID = OMP_GET_THREAD_NUM()
      PRINT *, 'Hello World from thread = ', TID

      ...

!$OMP END PARALLEL

      END
</PRE></FONT>
        <HR>
        Example 2: Incorrect <PRE>      PROGRAM HELLO

      INTEGER TID, OMP_GET_THREAD_NUM

!$OMP PARALLEL 

      TID = OMP_GET_THREAD_NUM()
      PRINT *, 'Hello World from thread = ', TID

      ...

!$OMP END PARALLEL

      END
</PRE></FONT>
        <HR>
        Example 3: Incorrect <PRE>      PROGRAM HELLO

      INTEGER TID, OMP_GET_THREAD_NUM

      TID = OMP_GET_THREAD_NUM()
      PRINT *, 'Hello World from thread = ', TID

!$OMP PARALLEL 

      ...

!$OMP END PARALLEL

      END
</PRE></TD></TR></TBODY></TABLE></P></LI></UL>
<P>
<HR>

<P><A name=OMP_GET_NUM_PROCS></A>
<H2>OMP_GET_NUM_PROCS</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Returns the number of processors that are available to the program. 
</LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TT> 
      <TD><PRE>INTEGER FUNCTION OMP_GET_NUM_PROCS()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_num_procs(void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P>
<HR>

<P><A name=OMP_IN_PARALLEL></A>
<H2>OMP_IN_PARALLEL</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>May be called to determine if the section of code which is executing is 
  parallel or not. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>LOGICAL FUNCTION OMP_IN_PARALLEL()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_in_parallel(void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, this function returns .TRUE. if it is called from the dynamic 
  extent of a region executing in parallel, and .FALSE. otherwise. For C/C++, it 
  will return a non-zero integer if parallel, and zero otherwise. </LI></UL>
<P>
<HR>

<P><A name=OMP_SET_DYNAMIC></A>
<H2>OMP_SET_DYNAMIC</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Enables or disables dynamic adjustment (by the run time system) of the 
  number of threads available for execution of parallel regions. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_SET_DYNAMIC(scalar_logical_expression)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
void omp_set_dynamic(int dynamic_threads)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, if called with .TRUE. then the number of threads available 
  for subsequent parallel regions can be adjusted automatically by the run-time 
  environment. If called with .FALSE., dynamic adjustment is disabled. 
  <P></P>
  <LI>For C/C++, if dynamic_threads evaluates to non-zero, then the mechanism is 
  enabled, otherwise it is disabled. 
  <P></P>
  <LI>The OMP_SET_DYNAMIC subroutine has precedence over the OMP_DYNAMIC 
  environment variable. 
  <P></P>
  <LI>The default setting is implementation dependent. 
  <P></P>
  <LI>Must be called from a serial section of the program. </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_DYNAMIC></A>
<H2>OMP_GET_DYNAMIC</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Used to determine if dynamic thread adjustment is enabled or not. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>LOGICAL FUNCTION OMP_GET_DYNAMIC()

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++ 
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_dynamic(void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, this function returns .TRUE. if dynamic thread adjustment is 
  enabled, and .FALSE. otherwise. 
  <P></P>
  <LI>For C/C++, non-zero will be returned if dynamic thread adjustment is 
  enabled, and zero otherwise. </LI></UL>
<P>
<HR>

<P><A name=OMP_SET_NESTED></A>
<H2>OMP_SET_NESTED</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Used to enable or disable nested parallelism. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_SET_NESTED(scalar_logical_expression)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
void omp_set_nested(int nested)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, calling this function with .FALSE. will disable nested 
  parallelism, and calling with .TRUE. will enable it. 
  <P></P>
  <LI>For C/C++, if nested evaluates to non-zero, nested parallelism is enabled; 
  otherwise it is disabled. 
  <P></P>
  <LI>The default is for nested parallelism to be disabled. 
  <P></P>
  <LI>This call has precedence over the OMP_NESTED environment variable </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_NESTED></A>
<H2>OMP_GET_NESTED</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Used to determine if nested parallelism is enabled or not. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>LOGICAL FUNCTION OMP_GET_NESTED

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++ 
      <TD><PRE>#include &lt;omp.h&gt;
int omp_get_nested (void)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, this function returns .TRUE. if nested parallelism is 
  enabled, and .FALSE. otherwise. 
  <P></P>
  <LI>For C/C++, non-zero will be returned if nested parallelism is enabled, and 
  zero otherwise. </LI></UL>
<P>
<HR>

<P><A name=OMP_INIT_LOCK></A>
<H2>OMP_INIT_LOCK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>This subroutine initializes a lock associated with the lock variable. 
</LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_INIT_LOCK(var)
SUBROUTINE OMP_INIT_NEST_LOCK(var)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++ 
      <TD><PRE>#include &lt;omp.h&gt;
void omp_init_lock(omp_lock_t *lock)
void omp_init_nest_lock(omp_nest_lock_t *lock)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>The initial state is unlocked 
  <P></P>
  <LI>For Fortran, <I><B>var</B></I> must be an integer large enough to hold an 
  address, such as INTEGER*8 on 64-bit systems. </LI></UL>
<P>
<HR>

<P><A name=OMP_DESTROY_LOCK></A>
<H2>OMP_DESTROY_LOCK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>This subroutine disassociates the given lock variable from any locks. 
</LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_DESTROY_LOCK(var)
SUBROUTINE OMP_DESTROY_NEST_LOCK(var)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
void omp_destroy_lock(omp_lock_t *lock)
void omp_destroy_nest__lock(omp_nest_lock_t *lock)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to call this routine with a lock variable that is not 
  initialized. 
  <P></P>
  <LI>For Fortran, <I><B>var</B></I> must be an integer large enough to hold an 
  address, such as INTEGER*8 on 64-bit systems. </LI></UL>
<P>
<HR>

<P><A name=OMP_SET_LOCK></A>
<H2>OMP_SET_LOCK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> 
<SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>This subroutine forces the executing thread to wait until the specified 
  lock is available. A thread is granted ownership of a lock when it becomes 
  available. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_SET_LOCK(var)
SUBROUTINE OMP_SET_NEST_LOCK(var)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
void omp_set_lock(omp_lock_t *lock)
void omp_set_nest__lock(omp_nest_lock_t *lock)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to call this routine with a lock variable that is not 
  initialized. 
  <P></P>
  <LI>For Fortran, <I><B>var</B></I> must be an integer large enough to hold an 
  address, such as INTEGER*8 on 64-bit systems. </LI></UL>
<P>
<HR>

<P><A name=OMP_UNSET_LOCK></A>
<H2>OMP_UNSET_LOCK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>This subroutine releases the lock from the executing subroutine. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_UNSET_LOCK(var)
SUBROUTINE OMP_UNSET_NEST_LOCK(var)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++ 
      <TD><PRE>#include &lt;omp.h&gt;
void omp_unset_lock(omp_lock_t *lock)
void omp_unset_nest__lock(omp_nest_lock_t *lock)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>It is illegal to call this routine with a lock variable that is not 
  initialized. 
  <P></P>
  <LI>For Fortran, <I><B>var</B></I> must be an integer large enough to hold an 
  address, such as INTEGER*8 on 64-bit systems. </LI></UL>
<P>
<HR>

<P><A name=OMP_TEST_LOCK></A>
<H2>OMP_TEST_LOCK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>This subroutine attempts to set a lock, but does not block if the lock is 
  unavailable. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>SUBROUTINE OMP_TEST_LOCK(var)
SUBROUTINE OMP_TEST_NEST_LOCK(var)

</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
int omp_test_lock(omp_lock_t *lock)
int omp_test_nest__lock(omp_nest_lock_t *lock)

</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>For Fortran, .TRUE. is returned if the lock was set successfully, 
  otherwise .FALSE. is returned. 
  <P></P>
  <LI>For Fortran, <I><B>var</B></I> must be an integer large enough to hold an 
  address, such as INTEGER*8 on 64-bit systems. 
  <P></P>
  <LI>For C/C++, non-zero is returned if the lock was set successfully, 
  otherwise zero is returned. 
  <P></P>
  <LI>It is illegal to call this routine with a lock variable that is not 
  initialized. </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_WTIME></A>
<H2>OMP_GET_WTIME</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Provides a portable wall clock timing routine 
  <P></P>
  <LI>Returns a double-precision floating point value equal to the number of 
  elapsed seconds since some point in the past. Usually used in "pairs" with the 
  value of the first call subtracted from the value of the second call to obtain 
  the elapsed time for a block of code. 
  <P></P>
  <LI>Designed to be "per thread" times, and therefore may not be globally 
  consistent across all threads in a team - depends upon what a thread is doing 
  compared to other threads. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>DOUBLE PRECISION FUNCTION OMP_GET_WTIME()
 
</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
double omp_get_wtime(void)
 
</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Requires OpenMP version 2.0 support </LI></UL>
<P>
<HR>

<P><A name=OMP_GET_WTICK></A>
<H2>OMP_GET_WTICK</H2><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" 
align=top> <SPAN class=heading3>Purpose:</SPAN> 
<UL>
  <P>
  <LI>Provides a portable wall clock timing routine 
  <P></P>
  <LI>Returns a double-precision floating point value equal to the number of 
  seconds between successive clock ticks. </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Format:</SPAN> 
<UL>
  <P>
  <TABLE cellSpacing=0 cellPadding=5 width="90%" border=1>
    <TBODY>
    <TR>
      <TH width="5%">Fortran</TH>
      <TD><PRE>DOUBLE PRECISION FUNCTION OMP_GET_WTICK()
 
</B></PRE></TD></TR>
    <TR>
      <TH width="5%">C/C++</TH>
      <TD><PRE>#include &lt;omp.h&gt;
double omp_get_wtick(void)
 
</B></PRE></TD></TR></TBODY></TABLE></P></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Notes &amp; Restrictions:</SPAN> 
<UL>
  <P>
  <LI>Requires OpenMP version 2.0 support </LI></UL><!--------------------------------------------------------------------------><A 
name=EnvironmentVariables><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>Environment Variables</SPAN> 
  </TD></TR></TBODY></TABLE><BR>
<UL>
  <P>
  <LI>OpenMP provides four environment variables for controlling the execution 
  of parallel code. 
  <P></P>
  <LI>All environment variable names are uppercase. The values assigned to them 
  are not case sensitive. 
  <P>
  <DL>
    <P>
    <DT><B>OMP_SCHEDULE</B> 
    <P></P>
    <DD>Applies only to DO, PARALLEL DO (Fortran) and <TT>for, parallel for</TT> 
    (C/C++) directives which have their schedule clause set to RUNTIME. The 
    value of this variable determines how iterations of the loop are scheduled 
    on processors. For example: 
    <P><TT><B>setenv OMP_SCHEDULE "guided, 4" <BR>setenv OMP_SCHEDULE "dynamic" 
    </B></TT>
    <P></P>
    <DT><B>OMP_NUM_THREADS</B> 
    <P></P>
    <DD>Sets the maximum number of threads to use during execution. For example: 

    <P><TT><B>setenv OMP_NUM_THREADS 8 </B></TT>
    <P></P>
    <DT><B>OMP_DYNAMIC</B> 
    <P></P>
    <DD>Enables or disables dynamic adjustment of the number of threads 
    available for execution of parallel regions. Valid values are TRUE or FALSE. 
    For example: 
    <P><TT><B>setenv OMP_DYNAMIC TRUE </B></TT>
    <P></P>
    <DT><B>OMP_NESTED</B> 
    <P></P>
    <DD>Enables or disables nested parallelism. Valid values are TRUE or FALSE. 
    For example: 
    <P><TT><B>setenv OMP_NESTED TRUE </B></TT></P></DD></DL>
  <P></P>
  <LI>Implementation notes: 
  <UL>
    <P>
    <LI>Your implementation may or may not support nested parallelism and/or 
    dynamic threads. If nested parallelism is supported, it is often only 
    nominal, in that a nested parallel region may only have one thread. 
    <P></P>
    <LI>Consult your implementation's documentation for details - or experiment 
    and find out for yourself if you can't find it in the documentation. 
  </LI></UL></TD></TR></TABLE></LI></UL><!--------------------------------------------------------------------------><A 
name=Issues><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>Memory and Performance 
      Issues</SPAN> </TD></TR></TBODY></TABLE>
<P><BR><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Thread Stack Size:</SPAN> 
<UL>
  <P>
  <LI>The OpenMP standard does not specify how much stack space a thread should 
  have. Consequently, implementations will differ in the default thread stack 
  size. 
  <P></P>
  <LI>Typically, default thread stack size is easy to exhaust. For example: 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 border=1>
    <TBODY>
    <TR>
      <TH>Compiler</TH>
      <TH>Stack Limit</TH>
      <TH>Approx. Array Size (doubles)</TH></TR>
    <TR>
      <TD>IBM AIX:</TD>
      <TD align=middle>4 MB</TD>
      <TD align=right>707 x 707</TD></TR>
    <TR>
      <TD>Intel IA32 Linux</TD>
      <TD align=middle>8 MB</TD>
      <TD align=right>1000 x 1000</TD></TR></TBODY></TABLE>
  <P></P>
  <LI>Threads that exceed their stack allocation may or may not seg fault. An 
  application may continue to run while data is being corrupted. 
  <P></P>
  <LI>Statically linked codes may be subject to further stack restrictions. 
  <P></P>
  <LI>Examples for increasing the thread stack size to 12 MB: 
  <P>
  <TABLE cellSpacing=0 cellPadding=5 border=1>
    <TBODY>
    <TR>
      <TH>Platform</TH>
      <TH>Shell Commands<BR>csh</TH>
      <TH>Shell Commands<BR>ksh</TH></TR>
    <TR>
      <TD>IBM AIX</TD>
      <TD><TT>limit stacksize 12288 <BR>setenv XLSMPOPTS 
      "stack=12000000"</TT></TD>
      <TD><TT>ulimit -s 12288 <BR>export XLSMPOPTS="stack=12000000"</TT></TD></TR>
    <TR>
      <TD>IA-32 Linux</TD>
      <TD><TT>limit stacksize 12288 <BR>setenv KMP_STACKSIZE 12000000</TT></TD>
      <TD><TT>ulimit -s 12288 <BR>export 
    KMP_STACKSIZE=12000000</TT></TD></TR></TBODY></TABLE></P></LI></UL><!--------------------------------------------------------------------------><A 
name=LLNL><BR><BR></A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>LLNL Specific Information and 
      Recommendations</SPAN> </TD></TR></TBODY></TABLE>
<P><BR><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>LC OpenMP Implementations:</SPAN> 
<UL>
  <P>
  <LI>OpenMP is fully supported all of LC's IBM, Intel and Opteron systems. 
  <P></P>
  <LI>LC maintains different versions of compilers. For the most recent 
  information, please see: <A 
  href="http://www.llnl.gov/asci/platforms/bluepac/CompsAvails.html" 
  target=W1>www.llnl.gov/asci/platforms/bluepac/CompsAvails.html</A> 
  <P></P>
  <LI>All versions should be at least OpenMP 2.0 compliant </LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Compiling:</SPAN> 
<UL>
  <P>
  <LI>Use the following compiler flags to "turn on" OpenMP compilations: 
  <P>
  <TABLE cellSpacing=1 cellPadding=5 width="50%" border=1>
    <TBODY>
    <TR vAlign=top>
      <TH>Compiler</TH>
      <TH>Flag</TH></TR>
    <TR vAlign=top>
      <TD>IBM</TD>
      <TD><TT>-qsmp=omp</TT></TD></TR>
    <TR vAlign=top>
      <TD>Intel</TD>
      <TD><TT>-openmp</TT></TD></TR>
    <TR vAlign=top>
      <TD>PathScale</TD>
      <TD><TT>-mp</TT></TD></TR>
    <TR vAlign=top>
      <TD>PGI</TD>
      <TD><TT>-mp</TT></TD></TR></TBODY></TABLE></P></LI></UL>
<P><IMG hspace=3 src="OpenMP.files/arrowBullet.gif" align=top> <SPAN 
class=heading3>Documentation:</SPAN> 
<UL>
  <P>
  <LI>IBM compiler documentation: <BR><A 
  href="http://www-4.ibm.com/software/ad/fortran" 
  target=W2>www-4.ibm.com/software/ad/fortran</A> and <A 
  href="http://www-4.ibm.com/software/ad/caix" 
  target=W3>www-4.ibm.com/software/ad/caix</A> <BR>Locally: see the 
  /usr/local/doc/xlf* and /usr/local/doc/xlc* files; man pages. 
  <P></P>
  <LI>Intel compiler documentation: <BR><A 
  href="http://www.intel.com/software/products/compilers/" 
  target=W4>www.intel.com/software/products/compilers/</A> <BR>Locally: see the 
  /usr/local/doc/ia32_ref and /usr/local/doc/intel_compilers files; man pages 
  <P></P>
  <LI>PathScale: <BR><A href="http://www.pathscale.com/" 
  target=W5>http://www.pathscale.com/</A> <BR>Locally: man pages 
  <P></P>
  <LI>PGI: <BR><A href="http://www.pgroup.com/" 
  target=W6>http://www.pgroup.com/</A> <BR>Locally: man pages </LI></UL>
<P>
<HR>

<P><FONT size=+1><B>This completes the tutorial.</B></FONT> 
<P>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR vAlign=top>
    <TD><A href="https://computing.llnl.gov/tutorials/evaluation/index.html" 
      target=evalForm><IMG alt="Evaluation Form" 
      src="OpenMP.files/evaluationForm.gif" border=0></A> &nbsp; &nbsp; 
&nbsp;</TD>
    <TD>Please complete the online evaluation form - unless you are doing the 
      exercise, in which case please complete it at the end of the 
  exercise.</TD></TR></TBODY></TABLE>
<P><FONT size=+1><B>Where would you like to go now?</B></FONT> 
<UL>
  <LI><A 
  href="https://computing.llnl.gov/tutorials/openMP/exercise.html">Exercise</A> 
  <LI><A 
  href="https://computing.llnl.gov/tutorials/agenda/index.html">Agenda</A> 
  <LI><A href="https://computing.llnl.gov/tutorials/openMP/#top">Back to the 
  top</A> </LI></UL><!--------------------------------------------------------------------------><A 
name=References><BR><BR>&nbsp; </A>
<TABLE cellSpacing=0 cellPadding=5 width="100%" border=1>
  <TBODY>
  <TR>
    <TD bgColor=#98abce><SPAN class=heading1>References and More 
      Information</SPAN> </TD></TR></TBODY></TABLE><BR>
<UL>
  <P>
  <LI>Author: <A href="mailto:blaiseb@llnl.gov">Blaise Barney</A>, Livermore 
  Computing. 
  <P></P>
  <LI>The OpenMP web site, which includes the C/C++ and Fortran Application 
  Program Interface documents. <BR><A href="http://www.openmp.org/" 
  target=W9>http://www.openmp.org/</A> </LI></UL><!-------------------------------------------------------------------------->
<SCRIPT language=JavaScript>PrintFooter("UCRL-MI-133316")</SCRIPT>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR></FORM></BASEFONT></BODY></HTML>
